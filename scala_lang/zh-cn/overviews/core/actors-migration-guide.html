
<!DOCTYPE html>
<html>
  <head>
    <title>Scala Actors迁移指南 - Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <link rel="icon" type="image/png" href="/resources/favicon.ico">

    <!-- prettify js and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/prettify.css" type="text/css" />
    <script src="/resources/javascript/prettify/prettify.js" type="text/javascript" ></script>


    <!-- jquery js -->
    <script src="/resources/javascript/jquery.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.core.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.highlight.js" type="text/javascript" ></script>
    <script src="/resources/javascript/moveScroller.js" type="text/javascript" ></script>

    <!-- Bootstrap JS and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/bootstrap.css" type="text/css" />
	  <script src="/resources/javascript/bootstrap-dropdown.js" type="text/javascript" ></script>
	  <script src="/resources/javascript/bootstrap-dropdown-app.js" type="text/javascript" ></script>

    <!-- Base stylesheet for all pages -->
    <link rel="stylesheet" href="/resources/stylesheets/base.css" type="text/css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css" />
    <link rel="stylesheet" href="/resources/stylesheets/search.css" type="text/css" />

    <!-- table of contents js -->
    <script src="/resources/javascript/toc.js" type="text/javascript" ></script>


    <!-- styles for pager and table of contents -->
    <link rel="stylesheet" href="/resources/stylesheets/pager.css" type="text/css" />
    <link rel="stylesheet" href="/resources/stylesheets/toc.css" type="text/css" />

    <!-- google analytics -->
	<script type="text/javascript">

	  var _gaq = _gaq || [];
	  _gaq.push(['_setAccount', 'UA-574683-5']);
	  _gaq.push(['_trackPageview']);

	  (function() {
	    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	  })();

	</script>

    <!-- prettyprint js to prepend generated pre/code tags -->
    <script type="text/javascript">
      function styleCode()
        {
          if (typeof disableStyleCode != "undefined")
          {
              return;
          }
          var a = false;
          $("pre code").parent().each(function()
          {
              if (!$(this).hasClass("prettyprint"))
              {
                  $(this).addClass("prettyprint lang-scala linenums");
                  a = true
              }
          });
          if (a) { prettyPrint() }
      }
    </script>

    <script type="text/javascript">
      jQuery(document).ready(function($) {

            $(".scroll").click(function(event){
              event.preventDefault();
              $('html,body').animate({scrollTop:$(this.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(this.hash).offset().top-=50}, 500);
              $(this.hash).effect("highlight", {color: "#FFCC85"}, 3000);
            });
      });
    </script>

    <script type="text/javascript">
      $(window).ready(function goToSubsection() {
          if (window.location.hash)
          {
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top-=50}, 500);
              $(window.location.hash).effect("highlight", {color: "#FFCC85"}, 3000);
          }
        });
    </script>

    <style type="text/css">

       p.contents {
           margin-left: 15px;
           font-weight: bold;
           font-size: 16px;
       }

       div#toc ul {
           list-style: none;
       }

       div#toc ul a {
           display: block;
           list-style: none;
           line-height: 22px;
           font-weight: bold;
           width: 100%;
       }

      div#toc ul li ul {
           list-style: disc;
      }

      div#toc ul li ul a {
           line-height: 18px;
           font-weight: normal;
      }

      div#toc ul li ul li ul {
           list-style: square;
      }
       div#toc ul li ul li ul a {
       }

       div#scroller-anchor {
           width: inherit;
       }

       div#scroller {
           width: inherit;
       }

       div#guide-title {
        text-transform: capitalize;
        font-size: 16px;
        padding-bottom: 6px;
        color: #BFBFBF;
        text-transform: uppercase;
        font-weight: bold;
       }

       input, textarea, select, .uneditable-input {
	       width: 165px;
	     }

    </style>

</head>
<body onload="styleCode()">

    <!-- Topbar
    ================================================== -->
<div class="topbar">
    <div class="topbar-inner">
        <div class="container">
            <a class="brand" href="/index.html"><img src="/resources/images/scala-logo.png"> Documentation</a>
            <ul class="nav">

                <li class="menu">
                      <a href="#" class="menu">API</a>
                      <ul class="menu-dropdown">
                        <li><a href="http://www.scala-lang.org/api/current/">Current</a></li>
                        <li><a href="http://www.scala-lang.org/files/archive/nightly/2.11.x/api/2.11.x/">Nightly</a></li>
                        <!--<li class="divider"></li>
                        <li><a href="#">Previous Versions</a></li>
                        -->
                      </ul>
                </li>

                <li class="menu">
                      <a href="#" class="menu">Learn</a>
                      <ul class="menu-dropdown">
                        <li><a href="/overviews">Guides & Overviews</a></li>
                        <li><a href="/tutorials">Tutorials</a></li>
                        <li><a href="/style">Scala Style Guide</a></li>
                      </ul>
                </li>

                <li class="menu">
                      <a href="#" class="menu">Quickref</a>
                      <ul class="menu-dropdown">
                        <li><a href="/glossary">Glossary</a></li>
                        <li><a href="/cheatsheets">Cheatsheets</a></li>
                      </ul>
                </li>

                <li><a href="/contribute.html">Contribute</a></li>
                <li><a href="/sips">SIPs/SLIPs</a></li>
                <li>
                    <form id="searchform" action="#">
                        <input type="text" placeholder="Search in documentation..." class="field" name="q" id="q"/>
                    </form>
                </li>
            </ul>
        </div>
    </div>
</div>


<div class="container">
  <div class="row">
    <div class="span10"><h1>Scala Actors迁移指南</h1></div>

    

    

    

    <div class="span6">
      
      <ul class="langbar">
        <li><a href="/overviews/core/actors-migration-guide" class="lang">English</a></li>
        
          
          <li><a href="/zh-cn/overviews/core/actors-migration-guide" class="lang">中文 (简体)</a></li>
        
      </ul>
      
    </div>

    <div class="span10">
      <p><strong>Vojin Jovanovic 和 Philipp Haller 著</strong></p>

<h2 id="section">概述</h2>

<p>从Scala的2.11.0版本开始，Scala的Actors库已经过时了。早在Scala2.10.0的时候，默认的actor库即是Akka。</p>

<p>为了方便的将Scala Actors迁移到Akka，我们提供了Actor迁移工具包（AMK）。通过在一个项目的类路径中添加scala-actors-migration.jar，AMK包含了一个针对Scala Actors扩展。此外，Akka 2.1包含一些特殊功能，比如ActorDSL singleton，可以实现更简单的转换功能，使Scala Actors代码变成Akka代码。本章内容的目的是用来指导用户完成迁移过程，并解释如何使用AMK。</p>

<p>本指南包括以下内容：在“迁移工具的局限性”章节中，我们在此概述了迁移工具的主要局限性。在“迁移概述”章节中我们描述了迁移过程和谈论了Scala的变化分布，使得迁移成为一种可能。最后，在“一步一步指导迁移到Akka”章节里，我们展示了一些迁移工作的例子，以及各个步骤，如果需要从Scala Actors迁移至Akka’s actors，本节是推荐阅读的。</p>

<p>免责声明:并发代码是臭名昭著的，当出现bug时很难调试和修复。由于两个actor的不同实现，这种差异导致可能出现错误。迁移过程没一步后都建议进行完全的代码测试。</p>

<h2 id="section-1">迁移工具的局限性</h2>

<p>由于Akka和Scala的actor模型的完整功能不尽相同导致两者之间不能平滑地迁移。下面的列表解释了很难迁移的部分行为：</p>

<ol>
  <li>
    <p>依靠终止原因和双向行为链接方法 - Scala和Akka actors有不同的故障处理和actor monitoring模型。在Scala actors模型中，如果一个相关联部分异常终止，相关联的actors终止。如果终止是显式跟踪(通过self.trapExit)，actor可以从失败的actor收到终止的原因。通过Akka这个功能不能迁移到AMK。AMK允许迁移的只是<a href="http://doc.akka.io/docs/akka/2.1.0/general/supervision.html#What_Lifecycle_Monitoring_Means">Akka monitoring</a>机制。Monitoring不同于连接,因为它是单向(unindirectional)的并且终止的原因是现在已知的。如果仅仅是monitoring机制是无法满足需求的,迁移的链接必须推迟到最后一刻(步骤5的迁移)。然后,当迁移到Akka,用户必须创建一个<a href="http://doc.akka.io/docs/akka/2.1.0/general/supervision.html">监督层次(supervision hierarchy)</a>,处理故障。</p>
  </li>
  <li>
    <p>使用restart方法——Akka不提供显式的重启actors，因此上述例子我们不能提供平滑迁移。用户必须更改系统,所以没有使用重启方法(restart method)。</p>
  </li>
  <li>
    <p>使用getState方法 - Akka actors没有显式状态,此功能无法迁移。用户代码必须没有getState调用。</p>
  </li>
  <li>
    <p>实例化后没有启动actors - Akka actors模型会在实例化后自动启动actors，所以用户不需要重塑系统来显式的在实例化后启动actors。</p>
  </li>
  <li>
    <p>mailboxSize方法不存在Akka中,因此不能迁移。这种方法很少使用,很容易被删除。</p>
  </li>
</ol>

<h2 id="section-2">迁移概述</h2>

<h3 id="section-3">迁移工具</h3>

<p>在Scal 2.10.0 actors 是在<a href="http://www.scala-lang.org/downloads">Scala distribution</a>中作为一个单独包（scala-actors.jar）存在的，并且他们的接口已被弃用。这种分布也包含在Akka actors的akka-actor.jar里。AMK同时存在Scala actors 和 akka-actor.jar之中。未来的主要版本的Scala将不包含Scala actors和AMK。</p>

<p>开始迁移，用户需要添加scala-actors.jar和scala-actors-migration.jar来构建他们的项目。添加scala-actors.jar和scala-actors-migration.jar允许使用下面描述的AMK。这些jar位于<a href="https://oss.sonatype.org/content/groups/scala-tools/org/scala-lang/">Scala Tools</a>库和<a href="http://www.scala-lang.org/downloads">Scala distribution</a>库中。</p>

<h3 id="section-4">一步一步来迁移</h3>

<p>Actor迁移工具使用起来应该有5步骤。每一步都设计为引入的基于代码的最小变化。在前四个迁移步骤的代码中将使用Scala actors来实现，并在该步完成后运行所有的系统测试。然而,方法和类的签名将被转换为与Akka相似。迁移工具在Scal方面引入了一种新的actor类型（ActWithStash）和强制执行actors的ActorRef接口。</p>

<p>该结果同样强制通过一个特殊的方法在ActorDSL 对象上创建actors。在这些步骤可以每次迁移一个actor。这降低了在同一时刻引入多个bug的可能性，同样降低了bug的复杂程度。</p>

<p>在Scala方面迁移完成后，用户应该改变import语句并变成使用Akka库。在Akka方面，ActorDSL和ActWithStash允许对Scala Actors和他们的生态系的react construct进行建模。这个步骤迁移所有actors到Akka的后端，会在系统中引入bug。一旦代码迁移到Akka,用户将能够使用Akka的所有的功能的。</p>

<h3 id="akka">一步一步指导迁移到Akka</h3>

<p>在这一章中,我们将通过actor迁移的5个步骤。在每一步之后的代码都要为可能的错误进行检测。在前4个步骤中可以一边迁移一个actor和一边测试功能。然而,最后一步迁移所有actors到Akka后它只能作为一个整体进行测试。在这个步骤之后系统应该具有和之前一样相同的功能，不过它将使用Akka actor库。</p>

<h3 id="actor">步骤1——万物皆是Actor</h3>

<p>Scala actors库提供了公共访问多个类型的actors。他们被组织在类层次结构和每个子类提供了稍微更丰富的功能。为了进一步的使迁移步骤更容易，我们将首先更改Actor类型系统中的每一个actor。这种迁移步骤很简单，因为Actor类位于层次结构的底部，并提供了广泛的功能。</p>

<p>来自Scala库的Actors应根据以下规则进行迁移：</p>

<ol>
  <li>class MyServ extends Reactor[T] -&gt; class MyServ extends Actor</li>
</ol>

<p>注意,反应器提供了一个额外的类型参数代表了类型的消息收到。如果用户代码中使用这些信息，那么一个需要：i）应用模式匹配与显式类型,或者ii）做一个向下的消息来自任何泛型T。</p>

<ol>
  <li>
    <p>class MyServ extends ReplyReactor -&gt; class MyServ extends Actor</p>
  </li>
  <li>
    <p>class MyServ extends DaemonActor -&gt; class MyServ extends Actor</p>
  </li>
</ol>

<p>为了为DaemonActor提供配对功能，将下列代码添加到类的定义。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>override def scheduler: IScheduler = DaemonScheduler
</code></pre>
</div>

<h3 id="section-5">步骤2 - 实例化</h3>

<p>在Akka中,actors可以访问只有通过ActorRef接口。ActorRef的实例可以通过在ActorDSL对象上调用actor方法或者通过调用ActorRefFactory实例的actorOf方法来获得。在Scala的AMK工具包中，我们提供了Akka ActorRef和ActorDSL的一个子集，该子集实际上是Akka库的一个单例对象(singleton object)。</p>

<p>这一步的迁移使所有actors访问通过ActorRefs。首先，我们现实如何迁移普通模式的实例化Sacla Actors。然后，我们将展示如何分别克服问题的ActorRef和Actor的不同接口。</p>

<h4 id="actor-1">Actor实例化</h4>

<p>actor实例的转换规则（以下规则需要import scala.actors.migration._）：</p>

<ol>
  <li>
    <p>构造器调用实例化</p>

    <div class="highlighter-rouge"><pre class="highlight"><code> val myActor = new MyActor(arg1, arg2)
 myActor.start()
</code></pre>
    </div>
  </li>
</ol>

<p>应该被替换</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ActorDSL.actor(new MyActor(arg1, arg2))
</code></pre>
</div>

<ol>
  <li>
    <p>用于创建Actors的DSL(译注：领域专用语言(Domain Specific Language))</p>

    <div class="highlighter-rouge"><pre class="highlight"><code> val myActor = actor {
   // actor 定义
 } 应该被替换

 val myActor = ActorDSL.actor(new Actor {
    def act() {
      // actor 定义
    }
 })
</code></pre>
    </div>
  </li>
  <li>
    <p>从Actor Trait扩展来的对象</p>

    <div class="highlighter-rouge"><pre class="highlight"><code> object MyActor extends Actor {
   // MyActor 定义
 }
 MyActor.start() 应该被替换

 class MyActor extends Actor {
   // MyActor 定义
 }
    
 object MyActor {
   val ref = ActorDSL.actor(new MyActor)
 } 所有的MyActor地想都应该被替换成MyActor.ref。
</code></pre>
    </div>
  </li>
</ol>

<p>需要注意的是Akka actors在实例化的同时开始运行。actors创建并开始在迁移的系统的情况下，actors在不同的位置以及改变这可能会影响系统的行为，用户需要更改代码，以使得actors在实例化后立即开始执行。</p>

<p>远程actors也需要被获取作为ActorRefs。为了得到一个远程actor ActorRef需使用方法selectActorRef。</p>

<h4 id="signatures">不同的方法签名(signatures)</h4>

<p>至此为止我们已经改变了所有的actor实例化，返回ActorRefs，然而，我们还没有完成迁移工作。有不同的接口在ActorRefs和Actors中，因此我们需要改变在每个迁移实例上触发的方法。不幸的是，Scala Actors提供的一些方法不能迁移。对下列方法的用户需要找到一个解决方案:</p>

<ol>
  <li>
    <p>getState()——Akka中的actors 默认情况下由其监管actors(supervising actors)负责管理和重启。在这种情况下,一个actor的状态是不相关的。</p>
  </li>
  <li>
    <p>restart() - 显式的重启一个Scala actor。在Akka中没有相应的功能。</p>
  </li>
</ol>

<p>所有其他Actor方法需要转换为两个ActorRef中的方法。转换是通过下面描述的规则。请注意,所有的规则需要导入以下内容:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import scala.concurrent.duration._
import scala.actors.migration.pattern.ask
import scala.actors.migration._
import scala.concurrent._ 额外规则1-3的作用域定义在无限的时间需要一个隐含的超时。然而，由于Akka不允许无限超时，我们会使用100年。例如：

implicit val timeout = Timeout(36500 days)
</code></pre>
</div>

<p>规则：</p>

<ol>
  <li>
    <p>!!(msg: Any): Future[Any] 被？替换。这条规则会改变一个返回类型到scala.concurrent.Future这可能导致类型不匹配。由于scala.concurrent.Future比过去的返回值具有更广泛的功能，这种类型的错误可以很容易地固定在与本地修改：</p>

    <div class="highlighter-rouge"><pre class="highlight"><code> actor !! message -&gt; respActor ? message
</code></pre>
    </div>
  </li>
  <li>
    <p>!![A] (msg: Any, handler: PartialFunction[Any, A]): Future[A] 被？取代。处理程序可以提取作为一个单独的函数，并用来生成一个future对象结果。处理的结果应给出另一个future对象结果,就像在下面的例子:</p>

    <div class="highlighter-rouge"><pre class="highlight"><code> val handler: PartialFunction[Any, T] = ... // handler
 actor !! (message, handler) -&gt; (respActor ? message) map handler
</code></pre>
    </div>
  </li>
  <li>
    <p>!? (msg: Any):任何被？替换都将阻塞在返回的future对象上</p>

    <div class="highlighter-rouge"><pre class="highlight"><code> actor !? message -&gt;
   Await.result(respActor ? message, Duration.Inf)
</code></pre>
    </div>
  </li>
  <li>
    <p>!? (msec: Long, msg: Any): Option[Any]任何被？替换都将显式的阻塞在future对象</p>

    <div class="highlighter-rouge"><pre class="highlight"><code> actor !? (dur, message) -&gt;
   val res = respActor.?(message)(Timeout(dur milliseconds))
   val optFut = res map (Some(_)) recover { case _ =&gt; None }
   Await.result(optFut, Duration.Inf)
</code></pre>
    </div>
  </li>
</ol>

<p>这里没有提到的公共方法是为了actors DSL被申明为公共的。他们只能在定义actor时使用，所以他们的这一步迁移是不相关的。</p>

<p>###第3步 -  从Actor 到 ActWithStash</p>

<p>到目前为止，所有的控制器都继承自Actor trait。我们通过指定的工厂方法来实例化控制器，所有的控制器都可以通过接口ActorRef 来进行访问。现在我们需要把所有的控制器迁移的AMK 的 ActWithStash 类上。这个类的行为方式和Scala的Actor几乎完全一致，它提供了另外一些方法，对应于Akka的Actor trait。这使得控制器更易于逐步的迁移到Akka。</p>

<p>为了达到这个目的，所有的从Actor继承的类，按照下列的方式，需要改为继承自ActWithStash：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class MyActor extends Actor -&gt; class MyActor extends ActWithStash
</code></pre>
</div>

<p>经过这样修改以后，代码会无法通过编译。因为ActWithStash中的receive 方法不能在act中像原来那样使用。要使代码通过编译，需要在所有的 receive 调用中加上类型参数。例如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  receive { case x: Int =&gt; "Number" } -&gt;
    receive[String] { case x: Int =&gt; "Number" }
</code></pre>
</div>

<p>另外，要使代码通过编译，还要在act方法前加上 override关键字，并且定义一个空的receive方法。act方法需要被重写，因为它在ActWithStash 的实现中模拟了Akka的消息处理循环。需要修改的地方请看下面的例子：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  class MyActor extends ActWithStash {
  
     // 空的 receive 方法 (现在还没有用)
     def receive = {case _ =&gt; }
  
     override def act() {
       // 原来代码中的 receive 方法改为 react。
     }
  } ActWithStash 的实例中，变量trapExit 的缺省值是true。如果希望改变，可以在初始化方法中把它设置为false。
</code></pre>
</div>

<p>远程控制器在ActWithStash 下无法直接使用，register(‘name, this)方法需要被替换为：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	registerActorRef('name, self)
</code></pre>
</div>

<p>在后面的步骤中， registerActorRef 和 alive 方法的调用与其它方法一样。</p>

<p>现在，用户可以测试运行，整个系统的运行会和原来一样。ActWithStash 和Actor 拥有相同的基本架构，所以系统的运行会与原来没有什么区别。</p>

<h3 id="act-">第4步 - 去掉act 方法</h3>

<p>在这一节，我们讨论怎样从ActWithStash中去掉act方法，以及怎样修改其他方法，使它与Akka更加契合. 这一环节会比较繁杂，所以我们建议最好一次只修改一个控制器。在Scala中，控制器的行为主要是在act方法的中定义。逻辑上来说，控制器是一个并发执行act方法的过程，执行完成后过程终止。在Akka中，控制器用一个全局消息处理器来依次处理它的的消息队列中的消息。这个消息处理器是一个receive函数返回的偏函数(partial function)，该偏函数被应用与每一条消息上。</p>

<p>因为ActWithStash中Akka方法的行为依赖于移除的act方法，所以我们首先要做的是去掉act方法。然后，我们需要按照给定的规则修改scala.actors.Actor中每个方法的。</p>

<h4 id="act--1">怎样去除act 方法</h4>

<p>在下面的列表中，我们给出了通用消息处理模式的修改规则。这个列表并不包含所有的模式，它只是覆盖了其中一些通用的模式。然而用户可以通过参考这些规则，通过扩展简单规则，将act方法移植到Akka。</p>

<p>嵌套调用react/reactWithin需要注意：消息处理偏函数需要做结构扩展，使它更接近Akka模式。尽管这种修改会很复杂，但是它允许任何层次的嵌套被移植。下面有相关的例子。</p>

<p>在复杂控制流中使用receive/receiveWithin需要注意：这个移植会比较复杂，因为它要求重构act方法。在消息处理偏函数中使用react 和 andThen可以使receive的调用模型化。下面是一些简单的例子。</p>

<ol>
  <li>
    <p>如果在act方法中有一些代码在第一个包含react的loop之前被执行，那么这些代码应该被放在preStart方法中。</p>

    <div class="highlighter-rouge"><pre class="highlight"><code> def act() {
   //初始化的代码放在这里
   loop {
     react { ... }
   }
 } 应该被替换
</code></pre>
    </div>

    <p>override def preStart() {
     //初始化的代码放在这里
   }</p>

    <p>def act() {
     loop {
       react{ … }
     }
   }
其他的模式，如果在第一个react 之前有一些代码，也可以使用这个规则。</p>
  </li>
  <li>
    <p>当act 的形式为：一个简单loop循环嵌套react，用下面的方法。</p>

    <div class="highlighter-rouge"><pre class="highlight"><code> def act() = {
   loop {
     react {
       // body
     }
   }
 } 应该被替换
</code></pre>
    </div>

    <p>def receive = {
     // body
   }</p>
  </li>
  <li>
    <p>当act包含一个loopWhile 结构，用下面的方法。</p>

    <div class="highlighter-rouge"><pre class="highlight"><code> def act() = {
   loopWhile(c) {
     react {
       case x: Int =&gt;
         // do task
         if (x == 42) {
           c = false
         }
     }
   }
 } 应该被替换
</code></pre>
    </div>

    <p>def receive = {
   case x: Int =&gt;
     // do task
     if (x == 42) {
       context.stop(self)
     }
 }</p>
  </li>
  <li>
    <p>当act包含嵌套的react，用下面的规则：</p>

    <div class="highlighter-rouge"><pre class="highlight"><code> def act() = {
   var c = true
   loopWhile(c) {
   react {
     case x: Int =&gt;
       // do task
       if (x == 42) {
         c = false
       } else {
         react {
           case y: String =&gt;
             // do nested task
         }
       }
     }
   }
 } 应该被替换
</code></pre>
    </div>

    <p>def receive = {
     case x: Int =&gt;
       // do task
       if (x == 42) {
         context.stop(self)
       } else {
         context.become(({
           case y: String =&gt;
           // do nested task
         }: Receive).andThen(x =&gt; {
           unstashAll()
           context.unbecome()
        }).orElse { case x =&gt; stash(x) })
       }
   }</p>
  </li>
  <li>
    <p>reactWithin方法使用下面的修改规则：</p>

    <div class="highlighter-rouge"><pre class="highlight"><code> loop {
   reactWithin(t) {
     case TIMEOUT =&gt; // timeout processing code
     case msg =&gt; // message processing code
   }
 } 应该被替换

 import scala.concurrent.duration._
    
 context.setReceiveTimeout(t millisecond)
 def receive = {
   case ReceiveTimeout =&gt; // timeout processing code
   case msg =&gt; // message processing code
 }
</code></pre>
    </div>
  </li>
  <li>
    <p>在Akka中，异常处理用另一种方式完成。如果要模拟Scala控制器的方式，那就用下面的方法</p>

    <div class="highlighter-rouge"><pre class="highlight"><code> def act() = {
   loop {
     react {
       case msg =&gt;
       // 可能会失败的代码
     }
   }
 }
    
 override def exceptionHandler = {
   case x: Exception =&gt; println("got exception")
 } 应该被替换
</code></pre>
    </div>

    <p>def receive = PFCatch({
     case msg =&gt;
       // 可能会失败的代码
   }, { case x: Exception =&gt; println(“got exception”) })
   PFCatch 的定义</p>

    <p>class PFCatch(f: PartialFunction[Any, Unit],
     handler: PartialFunction[Exception, Unit])
     extends PartialFunction[Any, Unit] {</p>

    <div class="highlighter-rouge"><pre class="highlight"><code> def apply(x: Any) = {
   try {
     f(x)
   } catch {
     case e: Exception if handler.isDefinedAt(e) =&gt;
       handler(e)
   }
 }
  
 def isDefinedAt(x: Any) = f.isDefinedAt(x)    }
</code></pre>
    </div>

    <p>object PFCatch {
     def apply(f: PartialFunction[Any, Unit],
       handler: PartialFunction[Exception, Unit]) =
         new PFCatch(f, handler)
   }</p>
  </li>
</ol>

<p>PFCatch并不包含在AMK之中，所以它可以保留在移植代码中，AMK将会在下一版本中被删除。当整个移植完成后，错误处理也可以改由Akka来监管。</p>

<h4 id="actor-2">修改Actor的方法</h4>

<p>当我们移除了act方法以后，我们需要替换在Akka中不存在，但是有相似功能的方法。在下面的列表中，我们给出了两者的区别和替换方法：</p>

<ol>
  <li>
    <p>exit()/exit(reason) - 需要由 context.stop(self) 替换</p>
  </li>
  <li>
    <p>receiver - 需要由 self 替换</p>
  </li>
  <li>
    <p>reply(msg) - 需要由 sender ! msg 替换</p>
  </li>
  <li>
    <p>link(actor) - 在Akka中，控制器之间的链接一部分由<a href="http://doc.akka.io/docs/akka/2.1.0/general/supervision.html#What_Supervision_Means">supervision</a>来完成，一部分由<a href="http://doc.akka.io/docs/akka/2.1.0/general/supervision.html#What_Lifecycle_Monitoring_Means">actor monitoring</a>来完成。在AMK中，我们只支持监测方法。因此，这部分Scala功能可以被完整的移植。</p>
  </li>
</ol>

<p>linking 和 watching 之间的区别在于：watching actor总是接受结束通知。然而，不像Scala的Exit消息包含结束的原因，Akka的watching 返回Terminated(a: ActorRef)消息，只包含ActorRef。获取结束原因的功能无法被移植。在Akka中，这一步骤可以在第4步之后，通过组织控制器的监管层级 <a href="http://doc.akka.io/docs/akka/2.1.0/general/supervision.html">supervision hierarchy</a>来完成。</p>

<p>如果watching actors收到的消息不撇陪结束消息，控制器会被终止并抛出DeathPactException异常。注意就算watching actors正常的结束，也会发生这种情况。在Scala中，linked actors只要一方不正常的终止，另一方就会以相同的原因终止。</p>

<p>如果系统不能单独的用 watch actors来 移植，用户可以像原来那样用link和exit(reason)来使用。然而，因为act()重载了Exit消息，需要做如下的修改：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  case Exit(actor, reason) =&gt;
    println("sorry about your " + reason)
    ... 应该被替换
  
  case t @ Terminated(actorRef) =&gt;
    println("sorry about your " + t.reason)
    ... 注意：在Scala和Akka的actor之间有另一种细微的区别：在Scala， link/watch 到已经终止的控制器不会有任何影响。在Akka中，看管已经终止的控制器会导致发送终止消息。这会在系统移植的第5 步导致不可预料的结果。
</code></pre>
</div>

<h3 id="akka-1">第5步 - Akka后端的移植</h3>

<p>到目前为止，用户代码已经做好了移植到Akka actors的准备工作。现在我们可以把Scala actors迁移到Akka actor上。为了完成这一目标，需要配置build，去掉scala-actors.jar 和 scala-actors-migration.jar，把 akka-actor.jar 和 typesafe-config.jar加进来。AMK只能在Akka actor 2.1下正常工作，Akka actor 2.1已经包含在分发包 <a href="http://www.scala-lang.org/downloads">Scala distribution</a>中， 可以用这样的方法配置。</p>

<p>经过这一步骤以后，因为包名的不同和API之间的细微差别，编译会失败。我们必须将每一个导入的actor从scala 修改为Akka。下列是部分需要修改的包名：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  scala.actors._ -&gt; akka.actor._
  scala.actors.migration.ActWithStash -&gt; akka.actor.ActorDSL._
  scala.actors.migration.pattern.ask -&gt; akka.pattern.ask
  scala.actors.migration.Timeout -&gt; akka.util.Timeout
</code></pre>
</div>

<p>当然，ActWithStash 中方法的声明 def receive = 必须加上前缀override。</p>

<p>在Scala actor中，stash 方法需要一个消息做为参数。例如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  def receive = {
    ...
    case x =&gt; stash(x)
  }
</code></pre>
</div>

<p>在Akka中，只有当前处理的消息可以被隐藏(stashed)。因此，上面的例子可以替换为：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    def receive = {
      ...
      case x =&gt; stash()
    }
</code></pre>
</div>

<h4 id="actor-system">添加Actor System</h4>

<p>Akka actor 组织在<a href="http://doc.akka.io/docs/akka/2.1.0/general/actor-systems.html">Actor systems</a>系统中。每一个被实例化的actor必须属于某一个ActorSystem。因此，要添加一个ActorSystem 实例作为每个actor 实例调用的第一个参数。下面给出了例子。</p>

<p>为了完成该转换，你需要有一个actor system 实例。例如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>val system = ActorSystem("migration-system")
</code></pre>
</div>

<p>然后，做如下转换：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ActorDSL.actor(...) -&gt; ActorDSL.actor(system)(...)
</code></pre>
</div>

<p>如果对actor 的调用都使用同一个ActorSystem ，那么它可以作为隐式参数来传递。例如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ActorDSL.actor(...) -&gt;
    import project.implicitActorSystem
    ActorDSL.actor(...)
</code></pre>
</div>

<p>当所有的主线程和actors结束后，Scala程序会终止。迁移到Akka后，当所有的主线程结束，所有的actor systems关闭后，程序才会结束。Actor systems 需要在程序退出前明确的中止。这需要通过在Actor system中调用shutdown 方法来完成。</p>

<h4 id="actors">远程 Actors</h4>

<p>当代码迁移到Akka，远程actors就不再工作了。 registerActorFor 和 alive 方法需要被移除。 在Akka中，远程控制通过配置独立的完成。更多细节请参考<a href="http://doc.akka.io/docs/akka/2.1.0/scala/remoting.html">Akka remoting documentation</a>。</p>

<h4 id="section-6">样例和问题</h4>

<p>这篇文档中的所有程序片段可以在<a href="http://github.com/scala/actors-migration/tree/master/src/test/">Actors Migration test suite</a>中找到，这些程序做为测试文件，前缀为actmig。</p>

<p>这篇文档和Actor移植组件由 <a href="http://people.epfl.ch/vojin.jovanovic">Vojin Jovanovic</a>和<a href="http://lampwww.epfl.ch/~phaller/">Philipp Haller</a>编写。</p>

<p>如果你发现任何问题或不完善的地方，请把它们报告给 <a href="https://github.com/scala/actors-migration/issues">Scala Bugtracker</a>。</p>


      <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  
    var disqus_shortname = 'scalasip'; // required: replace example with your forum shortname
  

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

    </div>
    
    <div class="span6">
      <div id="scroller-anchor">
  <div id="scroller">
              
    <p class="contents">Contents</p>
    <div id="toc"></div>    
  </div>
</div>

    </div>
    
	
  </div>
</div>

<div class="footer">
	<div class="container">
		<ul>
			<li><h5>API</h5></li>
			<li><a href="http://www.scala-lang.org/api/current/">Current</a></li>
			<li><a href="http://www.scala-lang.org/files/archive/nightly/2.11.x/api/2.11.x/">Nightly</a></li>
		</ul>
		<ul>
			<li><h5>Learn</h5></li>
			<li><a href="/overviews">Guides & Overviews</a></li>
			<li><a href="/tutorials">Tutorials</a></li>
			<li><a href="/style">Scala Style Guide</a></li>
		</ul>
		<ul>
			<li><h5>Quickref</h5></li>
			<li><a href="/glossary">Glossary</a></li>
			<li><a href="/cheatsheets">Cheatsheets</a></li>
		</ul>
		<ul>
			<li><h5>Contribute</h5></li>
			<li><a href="http://github.com/scala/scala.github.com">Source Code</a></li>
			<li><a href="/contribute.html">Contributors Guide</a></li>
			<li><a href="http://getsatisfaction.com/scaladocs">Suggestions</a></li>
		</ul>
		<ul>
			<li><h5>Other Resources</h5></li>
			<li><a href="/sips">Scala Improvement Process</a></li>
		</ul>
	</div>
	<div class="container copyright">
 		<p>
			Copyright &copy; 2011-2015 EPFL. All rights reserved.
			<a href="https://github.com/scala/scala.github.com/commits/gh-pages.atom"><img align="right" height="20px" width="20px" src="/resources/images/rss.png" alt="RSS feed of updates to the github repo hosting this site"></a>
		</p>
	</div>
</div>

<!-- search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
<script type="text/javascript"> docsearch({
  apiKey: 'b66eaeec6bd214ea6c0fcd2d7b7fdfe8',
  indexName: 'scala-docs',
  inputSelector: '#q',
	autocompleteOptions: {
    debug: true
  },
  algoliaOptions: {
		"hitsPerPage": 5,
		"facetFilters": "(tags:en)"
	}
});
</script>



<script type="text/javascript">
  $('#toc').toc({exclude: 'h1, h5, h6', context: '', autoId: true, numerate: false});
</script>

<script type="text/javascript">
  $(function() {
    moveScroller();
  });
</script>

  </body>
</html>

    
