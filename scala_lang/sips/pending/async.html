
<!DOCTYPE html>
<html>
  <head>
    <title>SIP-22 - Async - Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <link rel="icon" type="image/png" href="/resources/favicon.ico">

    <!-- prettify js and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/prettify.css" type="text/css" />
    <script src="/resources/javascript/prettify/prettify.js" type="text/javascript" ></script>


    <!-- jquery js -->
    <script src="/resources/javascript/jquery.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.core.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.highlight.js" type="text/javascript" ></script>
    <script src="/resources/javascript/moveScroller.js" type="text/javascript" ></script>

    <!-- Bootstrap JS and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/bootstrap.css" type="text/css" />
	  <script src="/resources/javascript/bootstrap-dropdown.js" type="text/javascript" ></script>
	  <script src="/resources/javascript/bootstrap-dropdown-app.js" type="text/javascript" ></script>

    <!-- Base stylesheet for all pages -->
    <link rel="stylesheet" href="/resources/stylesheets/base.css" type="text/css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css" />
    <link rel="stylesheet" href="/resources/stylesheets/search.css" type="text/css" />

    <!-- table of contents js -->
    <script src="/resources/javascript/toc.js" type="text/javascript" ></script>


    <!-- styles for pager and table of contents -->
    <link rel="stylesheet" href="/resources/stylesheets/pager.css" type="text/css" />
    <link rel="stylesheet" href="/resources/stylesheets/toc.css" type="text/css" />

    <!-- google analytics -->
	<script type="text/javascript">

	  var _gaq = _gaq || [];
	  _gaq.push(['_setAccount', 'UA-574683-5']);
	  _gaq.push(['_trackPageview']);

	  (function() {
	    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	  })();

	</script>

    <!-- prettyprint js to prepend generated pre/code tags -->
    <script type="text/javascript">
      function styleCode()
        {
          if (typeof disableStyleCode != "undefined")
          {
              return;
          }
          var a = false;
          $("pre code").parent().each(function()
          {
              if (!$(this).hasClass("prettyprint"))
              {
                  $(this).addClass("prettyprint lang-scala linenums");
                  a = true
              }
          });
          if (a) { prettyPrint() }
      }
    </script>

    <script type="text/javascript">
      jQuery(document).ready(function($) {

            $(".scroll").click(function(event){
              event.preventDefault();
              $('html,body').animate({scrollTop:$(this.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(this.hash).offset().top-=50}, 500);
              $(this.hash).effect("highlight", {color: "#FFCC85"}, 3000);
            });
      });
    </script>

    <script type="text/javascript">
      $(window).ready(function goToSubsection() {
          if (window.location.hash)
          {
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top-=50}, 500);
              $(window.location.hash).effect("highlight", {color: "#FFCC85"}, 3000);
          }
        });
    </script>

    <style type="text/css">

       p.contents {
           margin-left: 15px;
           font-weight: bold;
           font-size: 16px;
       }

       div#toc ul {
           list-style: none;
       }

       div#toc ul a {
           display: block;
           list-style: none;
           line-height: 22px;
           font-weight: bold;
           width: 100%;
       }

      div#toc ul li ul {
           list-style: disc;
      }

      div#toc ul li ul a {
           line-height: 18px;
           font-weight: normal;
      }

      div#toc ul li ul li ul {
           list-style: square;
      }
       div#toc ul li ul li ul a {
       }

       div#scroller-anchor {
           width: inherit;
       }

       div#scroller {
           width: inherit;
       }

       div#guide-title {
        text-transform: capitalize;
        font-size: 16px;
        padding-bottom: 6px;
        color: #BFBFBF;
        text-transform: uppercase;
        font-weight: bold;
       }

       input, textarea, select, .uneditable-input {
	       width: 165px;
	     }

    </style>

</head>
<body onload="styleCode()">
    
    <!-- Topbar
    ================================================== -->
    <div class="topbar" >
      <div class="topbar-inner">
        <div class="container">
          <a class="brand" href="/sips/index.html"><img src="/resources/images/scala-logo.png"> Improvement Process</a>
          <ul class="nav">
           <li><a href="/sips/sip-list.html">SIP List</a></li>
           <li><a href="/sips/minutes-list.html">Minutes</a></li>
           <li><a href="/sips/sip-submission.html">Submitting a SIP</a></li>
           <li><a href="/sips/slip-submission.html">Submitting a SLIP</a></li>
           <li><a href="/sips/sip-tutorial.html">Tutorial: Writing a SIP</a></li>
           <li><a href="https://groups.google.com/forum/#!forum/scala-sips">Mailing List</a></li>
          </ul>
        </div>
      </div>
    </div>


<div class="container">
  <div class="row">    

    <div class="span12">
      <h1>SIP-22 - Async</h1>    
      <p><strong>By: Philipp Haller and Jason Zaugg</strong></p>

<h2 id="introduction">Introduction</h2>

<p>This is a proposal to add constructs that simplify asynchronous and concurrent programming in Scala. The main constructs, async and await, are inspired by similar constructs introduced in C# 5.0. The main purpose of async/await is to make it possible to express efficient asynchronous code in a familiar direct style (where suspending operations look as if they were blocking). As a result, non-blocking code using Scala’s futures API [<a href="http://docs.scala-lang.org/overviews/core/futures.html" title="ScalaFutures">1</a>] can be expressed without using higher-order functions, such as map and flatMap, or low-level callbacks.</p>

<p>On the level of types, async and await are methods with simple, intuitive types:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def async[T](body: =&gt; T): Future[T]
def await[T](future: Future[T]): T
</code></pre>
</div>

<p>Here, <code class="highlighter-rouge">Future[T]</code> refers to the <code class="highlighter-rouge">Future</code> trait in package <code class="highlighter-rouge">scala.concurrent</code>. (The system can be adapted to other implementations of future-like abstractions; at the moment the API with the required extension points is internal, though.) The above methods are used as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>val fut = async {
  slowComputation()
}
</code></pre>
</div>

<p>The async construct marks a block of asynchronous code, and returns a future. Depending on the execution context in the implicit scope (see [<a href="http://docs.scala-lang.org/overviews/core/futures.html" title="ScalaFutures">1</a>]), the block of asynchronous code is either executed on the current thread or in a thread pool. The async block can contain calls to await:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>val futureDOY: Future[Response] =
  WS.url("http://api.day-of-year/today").get

val futureDaysLeft: Future[Response] =
  WS.url("http://api.days-left/today").get

val respFut = async {
  val dayOfYear = await(futureDOY).body
  val daysLeft = await(futureDaysLeft).body
  Ok(s"$dayOfYear: $daysLeft days left!")
}
</code></pre>
</div>

<p>Line 1 and 4 define two futures obtained as results of asynchronous requests to two hypothetical web services using an API inspired by Play Framework [<a href="http://www.playframework.com/" title="Play">2</a>] (for the purpose of this example, the definition of type <code class="highlighter-rouge">Response</code> is unimportant). The <code class="highlighter-rouge">await</code> on line 8 causes the execution of the <code class="highlighter-rouge">async</code> block to suspend until <code class="highlighter-rouge">futureDOY</code> is completed (with a successful result or with an exception). When the future is completed successfully, its result is bound to the <code class="highlighter-rouge">dayOfYear</code> val, and the execution of the <code class="highlighter-rouge">async</code> block is resumed. When the future is completed with an exception (for example, because of a timeout), the invocation of <code class="highlighter-rouge">await</code> re-throws the exception that the future was completed with. In turn, this completes future respFut with the same exception. Likewise, the <code class="highlighter-rouge">await</code> on line 9 suspends the execution of the <code class="highlighter-rouge">async</code> block until futureDaysLeft is completed.</p>

<h2 id="comparison-with-scalas-futures-api">Comparison with Scala’s Futures API</h2>

<p>The provided async and await constructs can significantly simplify code coordinating multiple futures. Consider the following example, written using Scala’s futures API together with for-comprehensions:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def nameOfMonth(num: Int): Future[String] = ...
val date = “““(\d+)/(\d+)“““.r

for { doyResponse &lt;- futureDOY
      dayOfYear = doyResponse.body
      response &lt;- dayOfYear match {
        case date(month, day) =&gt;
          for (name &lt;- nameOfMonth(month.toInt))
          yield Ok(s“It’s $name!“)
        case _ =&gt;
          Future.successful(NotFound(“Not a...“))
      }
} yield response
</code></pre>
</div>

<p>Line 1 defines an asynchronous method that converts an integer representing the number of a month to the name of the month (for example, the integer 2 is converted to “February”). Since the method is asynchronous, it returns a <code class="highlighter-rouge">Future[String]</code>. Line 2 defines a regular expression used to extract the month from a date string such as “07/24”. The for-comprehension starting on line 4 first awaits the result of <code class="highlighter-rouge">futureDOY</code> (the example re-uses the definition of <code class="highlighter-rouge">futureDOY</code> shown earlier). Scala’s futures provide methods like <code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">flatMap</code>, and can thus be used as generators in for-comprehensions (for a more in-depth introduction of this feature see the official documentation [<a href="http://docs.scala-lang.org/overviews/core/futures.html" title="ScalaFutures">1</a>]). The use of for-comprehensions can help make future-based code more clear, but in many cases it requires a significant amount of unnatural clutter and workarounds. The above example suffers from the following issues:</p>

<ul>
  <li>To extract <code class="highlighter-rouge">dayOfYear</code>, we are forced to introduce the name <code class="highlighter-rouge">doyResponse</code>, a useless intermediate result (line 4);</li>
  <li>to await the completion of the future returned by <code class="highlighter-rouge">nameOfMonth</code>, we are forced to use a nested for-comprehension (line 8);</li>
  <li>the nested for-comprehension forces us to bind the result of nameOfMonth to name, a useless intermediate variable (line 8);</li>
  <li>the nested for-comprehension forces us to introduce an artificial future that’s completed upon creation (line 11);</li>
  <li>the artificial future introduces additional overhead and garbage (line 11);</li>
  <li>finally, the use of for-yield might obscure the actual domain which is asynchronous computations with non-blocking awaits.</li>
</ul>

<p>The same example can be written using async/await as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>async {
  await(futureDOY).body match {
    case date(month, day) =&gt;
      Ok(s“It’s ${await(nameOfMonth(month.toInt))}!“)
    case _ =&gt;
      NotFound(“Not a date, mate!“)
  }
}
</code></pre>
</div>

<p>This version avoids all drawbacks of the previous version listed above. In addition, the generated code is more efficient, because it creates fewer closures.</p>

<h2 id="illegal-uses">Illegal Uses</h2>

<p>The following uses of await are illegal and are reported as errors:
- await requires a directly-enclosing async; this means await must not be used inside a closure nested within an async block, or inside a nested object, trait, or class.
- await must not be used inside an expression passed as an argument to a by-name parameter.
- await must not be used inside a Boolean short-circuit argument.
- return expressions are illegal inside an async block.</p>

<h2 id="implementation">Implementation</h2>

<p>We have implemented the present proposal using the macro system which has been introduced in Scala 2.10 as an experimental feature. Our implementation [<a href="https://github.com/scala/async" title="ScalaAsync">3</a>] is targeted at Scala 2.11.0, but runs on using Scala 2.10.1 without any limitations.</p>

<h2 id="async-transform-specification">Async Transform Specification</h2>

<p>In the following we consider the transformation of an invocation <code class="highlighter-rouge">async { &lt;block&gt; }</code> of the async macro.
Before the block of code (<code class="highlighter-rouge">&lt;block&gt;</code>) is transformed, it is normalized into a form amenable to a transformation into a state machine. This form is called the “A-Normal Form” (ANF), and roughly means that:</p>

<ul>
  <li><code class="highlighter-rouge">if</code>, <code class="highlighter-rouge">match</code>, and other control-flow  constructs are only used as statements; they cannot be used as expressions;</li>
  <li>calls to <code class="highlighter-rouge">await</code> are not allowed in compound expressions.</li>
</ul>

<p>After the ANF transform, the async macro prepares the state machine
transformation by identifying vals, vars and defs that are accessed
from multiple states. These will be lifted out to fields in the state
machine object.</p>

<p>The next step of the transformation breaks the code into “chunks.”
Each chunk contains a linear sequence of statements that concludes
with a branching decision, or with the registration of a subsequent
state handler as the continuation (the “on-completion handler”). Once
all chunks have been built, the macro synthesizes a class representing
the state machine. The class contains:</p>

<ul>
  <li>an integer representing the current state ID</li>
  <li>the lifted definitions</li>
  <li>an <code class="highlighter-rouge">apply(value: Try[Any]): Unit</code> method that will be called on completion of each future. The behavior of this method is determined by the current state. It records the downcast result of the future in a field, and calls the <code class="highlighter-rouge">resume()</code> method.</li>
  <li>the <code class="highlighter-rouge">resume(): Unit</code> method that switches on the current state and runs the users code for one “chunk,” and either: (a) registers the state machine as the handler for the next future, or (b) completes the result promise of the async block, if at the terminal state.</li>
  <li>an <code class="highlighter-rouge">apply(): Unit</code> method that starts the evaluation of the async block’s body.</li>
</ul>

<h3 id="example">Example</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>val future = async {                                     
  val f1 = async { true }                                 
  val x = 1                                               
  def inc(t: Int) = t + x                                 
  val t = 0                                               
  val f2 = async { 42 }                                   
  if (await(f1)) await(f2) else { val z = 1; inc(t + z) }
}
</code></pre>
</div>

<p>After the ANF transform:
- <code class="highlighter-rouge">await</code> calls are moved to only appear on the RHS of a value definition;
- <code class="highlighter-rouge">if</code> is no longer used as an expression; instead each branch writes its result to a synthetic var;
- the <code class="highlighter-rouge">ExecutionContext</code> used to run the async block is obtained as an implicit argument.</p>

<p>Follows the end result of the ANF transform (with very minor
simplifications).</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="err">();</span><span class="w">
  </span><span class="err">val</span><span class="w"> </span><span class="err">f1:</span><span class="w"> </span><span class="err">scala.concurrent.Future[Boolean]</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">{</span><span class="w">
    </span><span class="err">scala.concurrent.Future.apply[Boolean](true)(scala.concurrent.ExecutionContext.Implicits.global)</span><span class="w">
  </span><span class="p">}</span><span class="err">;</span><span class="w">
  </span><span class="err">val</span><span class="w"> </span><span class="err">x:</span><span class="w"> </span><span class="err">Int</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="mi">1</span><span class="err">;</span><span class="w">
  </span><span class="err">def</span><span class="w"> </span><span class="err">inc(t:</span><span class="w"> </span><span class="err">Int):</span><span class="w"> </span><span class="err">Int</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">t.+(x);</span><span class="w">
  </span><span class="err">val</span><span class="w"> </span><span class="err">t:</span><span class="w"> </span><span class="err">Int</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="mi">0</span><span class="err">;</span><span class="w">
  </span><span class="err">val</span><span class="w"> </span><span class="err">f</span><span class="mi">2</span><span class="err">:</span><span class="w"> </span><span class="err">scala.concurrent.Future</span><span class="p">[</span><span class="err">Int</span><span class="p">]</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="err">scala.concurrent.Future.apply[Int](42)(scala.concurrent.ExecutionContext.Implicits.global)</span><span class="w">
  </span><span class="p">}</span><span class="err">;</span><span class="w">
  </span><span class="err">val</span><span class="w"> </span><span class="err">await$</span><span class="mi">1</span><span class="err">:</span><span class="w"> </span><span class="err">Boolean</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">scala.async.Async.await</span><span class="p">[</span><span class="err">Boolean</span><span class="p">]</span><span class="err">(f</span><span class="mi">1</span><span class="err">);</span><span class="w">
  </span><span class="err">var</span><span class="w"> </span><span class="err">ifres$</span><span class="mi">1</span><span class="err">:</span><span class="w"> </span><span class="err">Int</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="mi">0</span><span class="err">;</span><span class="w">
  </span><span class="err">if</span><span class="w"> </span><span class="err">(await$</span><span class="mi">1</span><span class="err">)</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="err">val</span><span class="w"> </span><span class="err">await$2:</span><span class="w"> </span><span class="err">Int</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">scala.async.Async.await[Int](f2);</span><span class="w">
    </span><span class="err">ifres$1</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">await$2</span><span class="w">
  </span><span class="p">}</span><span class="w">
  </span><span class="err">else</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="err">ifres$1</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">{</span><span class="w">
      </span><span class="err">val</span><span class="w"> </span><span class="err">z:</span><span class="w"> </span><span class="err">Int</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">1;</span><span class="w">
      </span><span class="err">inc(t.+(z))</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="err">};</span><span class="w">
  </span><span class="err">ifres$</span><span class="mi">1</span><span class="w">
</span><span class="err">}</span><span class="w">
</span></code></pre>
</div>

<p>After the full async transform:</p>

<ul>
  <li>
    <p>one class is synthesized that represents the state machine. Its <code class="highlighter-rouge">apply()</code> method is used to start the computation (even the code before the first await call is executed asynchronously), and the <code class="highlighter-rouge">apply(tr: scala.util.Try[Any])</code> method will continue after each completed future that the async block awaits;</p>
  </li>
  <li>
    <p>each chunk of code is moved into the a branch of the pattern match in <code class="highlighter-rouge">resume$async</code>;</p>
  </li>
  <li>
    <p>value and function definitions accessed from multiple states are lifted to be members of class <code class="highlighter-rouge">stateMachine</code>; others remain local, e.g. <code class="highlighter-rouge">val z</code>;</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">result$async</code> holds the promise which is completed with the result of the async block;</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">execContext$async</code> holds the <code class="highlighter-rouge">ExecutionContext</code> that has been inferred.</p>
  </li>
</ul>

<p>Follows the end result of the full async transform (with very minor
simplifications).</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="err">class</span><span class="w"> </span><span class="err">stateMachine$7</span><span class="w"> </span><span class="err">extends</span><span class="w"> </span><span class="err">StateMachine[scala.concurrent.Promise[Int],</span><span class="w"> </span><span class="err">scala.concurrent.ExecutionContext]</span><span class="w"> </span><span class="err">{</span><span class="w">
    </span><span class="err">var</span><span class="w"> </span><span class="err">state$async:</span><span class="w"> </span><span class="err">Int</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">0;</span><span class="w">
    </span><span class="err">val</span><span class="w"> </span><span class="err">result$async:</span><span class="w"> </span><span class="err">scala.concurrent.Promise[Int]</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">scala.concurrent.Promise.apply[Int]();</span><span class="w">
    </span><span class="err">val</span><span class="w"> </span><span class="err">execContext$async</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">scala.concurrent.ExecutionContext.Implicits.global;</span><span class="w">
    </span><span class="err">var</span><span class="w"> </span><span class="err">x$1:</span><span class="w"> </span><span class="err">Int</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">0;</span><span class="w">
    </span><span class="err">def</span><span class="w"> </span><span class="err">inc$1(t:</span><span class="w"> </span><span class="err">Int):</span><span class="w"> </span><span class="err">Int</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">t.$plus(x$1);</span><span class="w">
    </span><span class="err">var</span><span class="w"> </span><span class="err">t$1:</span><span class="w"> </span><span class="err">Int</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">0;</span><span class="w">
    </span><span class="err">var</span><span class="w"> </span><span class="err">f2$1:</span><span class="w"> </span><span class="err">scala.concurrent.Future[Int]</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">null;</span><span class="w">
    </span><span class="err">var</span><span class="w"> </span><span class="err">await$1:</span><span class="w"> </span><span class="err">Boolean</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">false;</span><span class="w">
    </span><span class="err">var</span><span class="w"> </span><span class="err">ifres$1:</span><span class="w"> </span><span class="err">Int</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">0;</span><span class="w">
    </span><span class="err">var</span><span class="w"> </span><span class="err">await$2:</span><span class="w"> </span><span class="err">Int</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">0;</span><span class="w">
    </span><span class="err">def</span><span class="w"> </span><span class="err">resume$async():</span><span class="w"> </span><span class="err">Unit</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">try</span><span class="w"> </span><span class="err">{</span><span class="w">
      </span><span class="err">state$async</span><span class="w"> </span><span class="err">match</span><span class="w"> </span><span class="err">{</span><span class="w">
        </span><span class="err">case</span><span class="w"> </span><span class="err">0</span><span class="w"> </span><span class="err">=&gt;</span><span class="w"> </span><span class="err">{</span><span class="w">
          </span><span class="err">();</span><span class="w">
          </span><span class="err">val</span><span class="w"> </span><span class="err">f1</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">{</span><span class="w">
            </span><span class="err">scala.concurrent.Future.apply[Boolean](true)(scala.concurrent.ExecutionContext.Implicits.global)</span><span class="w">
          </span><span class="p">}</span><span class="err">;</span><span class="w">
          </span><span class="err">x$</span><span class="mi">1</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="mi">1</span><span class="err">;</span><span class="w">
          </span><span class="err">t$</span><span class="mi">1</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="mi">0</span><span class="err">;</span><span class="w">
          </span><span class="err">f</span><span class="mi">2</span><span class="err">$</span><span class="mi">1</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="err">scala.concurrent.Future.apply[Int](42)(scala.concurrent.ExecutionContext.Implicits.global)</span><span class="w">
          </span><span class="p">}</span><span class="err">;</span><span class="w">
          </span><span class="err">f</span><span class="mi">1</span><span class="err">.onComplete(this)(execContext$async)</span><span class="w">
        </span><span class="err">}</span><span class="w">
        </span><span class="err">case</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="err">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
          </span><span class="err">ifres$1</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">0;</span><span class="w">
          </span><span class="err">if</span><span class="w"> </span><span class="err">(await$1)</span><span class="w">
            </span><span class="err">{</span><span class="w">
              </span><span class="err">state$async</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">2;</span><span class="w">
              </span><span class="err">resume$async()</span><span class="w">
            </span><span class="p">}</span><span class="w">
          </span><span class="err">else</span><span class="w">
            </span><span class="p">{</span><span class="w">
              </span><span class="err">state$async</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">3;</span><span class="w">
              </span><span class="err">resume$async()</span><span class="w">
            </span><span class="p">}</span><span class="w">
        </span><span class="err">}</span><span class="w">
        </span><span class="err">case</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="err">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
          </span><span class="err">f2$1.onComplete(this)(execContext$async);</span><span class="w">
          </span><span class="err">()</span><span class="w">
        </span><span class="p">}</span><span class="w">
        </span><span class="err">case</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="err">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
          </span><span class="err">ifres$1</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">await$2;</span><span class="w">
          </span><span class="err">state$async</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">4;</span><span class="w">
          </span><span class="err">resume$async()</span><span class="w">
        </span><span class="p">}</span><span class="w">
        </span><span class="err">case</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="err">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
          </span><span class="err">ifres$1</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">{</span><span class="w">
            </span><span class="err">val</span><span class="w"> </span><span class="err">z</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">1;</span><span class="w">
            </span><span class="err">inc$1(t$1.$plus(z))</span><span class="w">
          </span><span class="p">}</span><span class="err">;</span><span class="w">
          </span><span class="err">state$async</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="mi">4</span><span class="err">;</span><span class="w">
          </span><span class="err">resume$async()</span><span class="w">
        </span><span class="err">}</span><span class="w">
        </span><span class="err">case</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="err">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
          </span><span class="err">result$async.complete(scala.util.Success.apply(ifres$1));</span><span class="w">
          </span><span class="err">()</span><span class="w">
        </span><span class="p">}</span><span class="w">
      </span><span class="err">}</span><span class="w">
    </span><span class="err">}</span><span class="w"> </span><span class="err">catch</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="err">case</span><span class="w"> </span><span class="err">NonFatal((tr</span><span class="w"> </span><span class="err">@</span><span class="w"> </span><span class="err">_))</span><span class="w"> </span><span class="err">=&gt;</span><span class="w"> </span><span class="err">{</span><span class="w">
        </span><span class="err">{</span><span class="w">
          </span><span class="err">result$async.complete(scala.util.Failure.apply(tr));</span><span class="w">
          </span><span class="err">()</span><span class="w">
        </span><span class="p">}</span><span class="err">;</span><span class="w">
        </span><span class="err">()</span><span class="w">
      </span><span class="err">}</span><span class="w">
    </span><span class="err">};</span><span class="w">
    </span><span class="err">def</span><span class="w"> </span><span class="err">apply(tr:</span><span class="w"> </span><span class="err">scala.util.Try</span><span class="p">[</span><span class="err">Any</span><span class="p">]</span><span class="err">):</span><span class="w"> </span><span class="err">Unit</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">state$async</span><span class="w"> </span><span class="err">match</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="err">case</span><span class="w"> </span><span class="err">0</span><span class="w"> </span><span class="err">=&gt;</span><span class="w"> </span><span class="err">{</span><span class="w">
        </span><span class="err">if</span><span class="w"> </span><span class="err">(tr.isFailure)</span><span class="w">
          </span><span class="err">{</span><span class="w">
            </span><span class="err">result$async.complete(tr.asInstanceOf[scala.util.Try[Int]]);</span><span class="w">
            </span><span class="err">()</span><span class="w">
          </span><span class="p">}</span><span class="w">
        </span><span class="err">else</span><span class="w">
          </span><span class="p">{</span><span class="w">
            </span><span class="err">await$1</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">tr.get.asInstanceOf[Boolean];</span><span class="w">
            </span><span class="err">state$async</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">1;</span><span class="w">
            </span><span class="err">resume$async()</span><span class="w">
          </span><span class="p">}</span><span class="err">;</span><span class="w">
        </span><span class="err">()</span><span class="w">
      </span><span class="err">}</span><span class="w">
      </span><span class="err">case</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="err">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="err">if</span><span class="w"> </span><span class="err">(tr.isFailure)</span><span class="w">
          </span><span class="err">{</span><span class="w">
            </span><span class="err">result$async.complete(tr.asInstanceOf[scala.util.Try[Int]]);</span><span class="w">
            </span><span class="err">()</span><span class="w">
          </span><span class="p">}</span><span class="w">
        </span><span class="err">else</span><span class="w">
          </span><span class="p">{</span><span class="w">
            </span><span class="err">await$2</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">tr.get.asInstanceOf[Int];</span><span class="w">
            </span><span class="err">state$async</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">5;</span><span class="w">
            </span><span class="err">resume$async()</span><span class="w">
          </span><span class="p">}</span><span class="err">;</span><span class="w">
        </span><span class="err">()</span><span class="w">
      </span><span class="err">}</span><span class="w">
    </span><span class="err">};</span><span class="w">
    </span><span class="err">def</span><span class="w"> </span><span class="err">apply:</span><span class="w"> </span><span class="err">Unit</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">resume$async()</span><span class="w">
  </span><span class="err">};</span><span class="w">
  </span><span class="err">val</span><span class="w"> </span><span class="err">stateMachine$</span><span class="mi">7</span><span class="err">:</span><span class="w"> </span><span class="err">StateMachine</span><span class="p">[</span><span class="err">scala.concurrent.Promise</span><span class="p">[</span><span class="err">Int</span><span class="p">],</span><span class="w"> </span><span class="err">scala.concurrent.ExecutionContext</span><span class="p">]</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">new</span><span class="w"> </span><span class="err">stateMachine$</span><span class="mi">7</span><span class="err">();</span><span class="w">
  </span><span class="err">scala.concurrent.Future.apply(stateMachine$</span><span class="mi">7</span><span class="err">.apply())(scala.concurrent.ExecutionContext.Implicits.global);</span><span class="w">
  </span><span class="err">stateMachine$</span><span class="mi">7</span><span class="err">.result$async.future</span><span class="w">
</span><span class="err">}</span><span class="w">
</span></code></pre>
</div>

<h2 id="references">References</h2>

<ol>
  <li><a href="http://docs.scala-lang.org/overviews/core/futures.html" title="ScalaFutures">The Scala Futures API</a></li>
  <li><a href="http://www.playframework.com/" title="Play">The Play! Framework</a></li>
  <li><a href="https://github.com/scala/async" title="ScalaAsync">Scala Async on GitHub</a></li>
</ol>


      <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  
    var disqus_shortname = 'scalasip'; // required: replace example with your forum shortname
  

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

    </div>
    
    <div class="span4">
      <div id="scroller-anchor">
  <div id="scroller">
              
        
          <p class="contents">SIP Committee Decision</p>
          <div class="alert-message warning" style="margin-left: 15px;">
            <strong style="font-size: 15px;">Postponed To A Future Release</strong>
            <p style="padding-top: 10px">Authors have asked to postpone until further notice. They will eventually open the proposal when some details in the implementation are ready. Check <a href="http://localhost:4000/sips/minutes/sip-minutes.html">July's minutes</a>.</p>
          </div>  
                        
              
    <p class="contents">Contents</p>
    <div id="toc"></div>    
  </div>
</div>

    </div>
  
  </div>
</div>

<div class="footer">
	<div class="container">
		<ul>
			<li><h5>API</h5></li>
			<li><a href="http://www.scala-lang.org/api/current/">Current</a></li>
			<li><a href="http://www.scala-lang.org/files/archive/nightly/2.11.x/api/2.11.x/">Nightly</a></li>
		</ul>
		<ul>
			<li><h5>Learn</h5></li>
			<li><a href="/overviews">Guides & Overviews</a></li>
			<li><a href="/tutorials">Tutorials</a></li>
			<li><a href="/style">Scala Style Guide</a></li>
		</ul>
		<ul>
			<li><h5>Quickref</h5></li>
			<li><a href="/glossary">Glossary</a></li>
			<li><a href="/cheatsheets">Cheatsheets</a></li>
		</ul>
		<ul>
			<li><h5>Contribute</h5></li>
			<li><a href="http://github.com/scala/scala.github.com">Source Code</a></li>
			<li><a href="/contribute.html">Contributors Guide</a></li>
			<li><a href="http://getsatisfaction.com/scaladocs">Suggestions</a></li>
		</ul>
		<ul>
			<li><h5>Other Resources</h5></li>
			<li><a href="/sips">Scala Improvement Process</a></li>
		</ul>
	</div>
	<div class="container copyright">
 		<p>
			Copyright &copy; 2011-2015 EPFL. All rights reserved.
			<a href="https://github.com/scala/scala.github.com/commits/gh-pages.atom"><img align="right" height="20px" width="20px" src="/resources/images/rss.png" alt="RSS feed of updates to the github repo hosting this site"></a>
		</p>
	</div>
</div>

<!-- search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
<script type="text/javascript"> docsearch({
  apiKey: 'b66eaeec6bd214ea6c0fcd2d7b7fdfe8',
  indexName: 'scala-docs',
  inputSelector: '#q',
	autocompleteOptions: {
    debug: true
  },
  algoliaOptions: {
		"hitsPerPage": 5,
		"facetFilters": "(tags:en)"
	}
});
</script>



<script type="text/javascript">
  $('#toc').toc({exclude: 'h1, h5, h6', context: '', autoId: true, numerate: false});
</script>

<script type="text/javascript">
  $(function() {
    moveScroller();
  });
</script>

  </body>
</html>

    