
<!DOCTYPE html>
<html>
  <head>
    <title>API de actores en Scala - Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <link rel="icon" type="image/png" href="/resources/favicon.ico">

    <!-- prettify js and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/prettify.css" type="text/css" />
    <script src="/resources/javascript/prettify/prettify.js" type="text/javascript" ></script>


    <!-- jquery js -->
    <script src="/resources/javascript/jquery.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.core.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.highlight.js" type="text/javascript" ></script>
    <script src="/resources/javascript/moveScroller.js" type="text/javascript" ></script>

    <!-- Bootstrap JS and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/bootstrap.css" type="text/css" />
	  <script src="/resources/javascript/bootstrap-dropdown.js" type="text/javascript" ></script>
	  <script src="/resources/javascript/bootstrap-dropdown-app.js" type="text/javascript" ></script>

    <!-- Base stylesheet for all pages -->
    <link rel="stylesheet" href="/resources/stylesheets/base.css" type="text/css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css" />
    <link rel="stylesheet" href="/resources/stylesheets/search.css" type="text/css" />

    <!-- table of contents js -->
    <script src="/resources/javascript/toc.js" type="text/javascript" ></script>


    <!-- styles for pager and table of contents -->
    <link rel="stylesheet" href="/resources/stylesheets/pager.css" type="text/css" />
    <link rel="stylesheet" href="/resources/stylesheets/toc.css" type="text/css" />

    <!-- google analytics -->
	<script type="text/javascript">

	  var _gaq = _gaq || [];
	  _gaq.push(['_setAccount', 'UA-574683-5']);
	  _gaq.push(['_trackPageview']);

	  (function() {
	    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	  })();

	</script>

    <!-- prettyprint js to prepend generated pre/code tags -->
    <script type="text/javascript">
      function styleCode()
        {
          if (typeof disableStyleCode != "undefined")
          {
              return;
          }
          var a = false;
          $("pre code").parent().each(function()
          {
              if (!$(this).hasClass("prettyprint"))
              {
                  $(this).addClass("prettyprint lang-scala linenums");
                  a = true
              }
          });
          if (a) { prettyPrint() }
      }
    </script>

    <script type="text/javascript">
      jQuery(document).ready(function($) {

            $(".scroll").click(function(event){
              event.preventDefault();
              $('html,body').animate({scrollTop:$(this.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(this.hash).offset().top-=50}, 500);
              $(this.hash).effect("highlight", {color: "#FFCC85"}, 3000);
            });
      });
    </script>

    <script type="text/javascript">
      $(window).ready(function goToSubsection() {
          if (window.location.hash)
          {
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top-=50}, 500);
              $(window.location.hash).effect("highlight", {color: "#FFCC85"}, 3000);
          }
        });
    </script>

    <style type="text/css">

       p.contents {
           margin-left: 15px;
           font-weight: bold;
           font-size: 16px;
       }

       div#toc ul {
           list-style: none;
       }

       div#toc ul a {
           display: block;
           list-style: none;
           line-height: 22px;
           font-weight: bold;
           width: 100%;
       }

      div#toc ul li ul {
           list-style: disc;
      }

      div#toc ul li ul a {
           line-height: 18px;
           font-weight: normal;
      }

      div#toc ul li ul li ul {
           list-style: square;
      }
       div#toc ul li ul li ul a {
       }

       div#scroller-anchor {
           width: inherit;
       }

       div#scroller {
           width: inherit;
       }

       div#guide-title {
        text-transform: capitalize;
        font-size: 16px;
        padding-bottom: 6px;
        color: #BFBFBF;
        text-transform: uppercase;
        font-weight: bold;
       }

       input, textarea, select, .uneditable-input {
	       width: 165px;
	     }

    </style>

</head>
<body onload="styleCode()">

    <!-- Topbar
    ================================================== -->
<div class="topbar">
    <div class="topbar-inner">
        <div class="container">
            <a class="brand" href="/index.html"><img src="/resources/images/scala-logo.png"> Documentation</a>
            <ul class="nav">

                <li class="menu">
                      <a href="#" class="menu">API</a>
                      <ul class="menu-dropdown">
                        <li><a href="http://www.scala-lang.org/api/current/">Current</a></li>
                        <li><a href="http://www.scala-lang.org/files/archive/nightly/2.11.x/api/2.11.x/">Nightly</a></li>
                        <!--<li class="divider"></li>
                        <li><a href="#">Previous Versions</a></li>
                        -->
                      </ul>
                </li>

                <li class="menu">
                      <a href="#" class="menu">Learn</a>
                      <ul class="menu-dropdown">
                        <li><a href="/overviews">Guides & Overviews</a></li>
                        <li><a href="/tutorials">Tutorials</a></li>
                        <li><a href="/style">Scala Style Guide</a></li>
                      </ul>
                </li>

                <li class="menu">
                      <a href="#" class="menu">Quickref</a>
                      <ul class="menu-dropdown">
                        <li><a href="/glossary">Glossary</a></li>
                        <li><a href="/cheatsheets">Cheatsheets</a></li>
                      </ul>
                </li>

                <li><a href="/contribute.html">Contribute</a></li>
                <li><a href="/sips">SIPs/SLIPs</a></li>
                <li>
                    <form id="searchform" action="#">
                        <input type="text" placeholder="Search in documentation..." class="field" name="q" id="q"/>
                    </form>
                </li>
            </ul>
        </div>
    </div>
</div>


<div class="container">
  <div class="row">
    <div class="span10"><h1>API de actores en Scala</h1></div>

    

    

    

    <div class="span6">
      
      <ul class="langbar">
        <li><a href="/overviews/core/actors" class="lang">English</a></li>
        
          
          <li><a href="/zh-cn/overviews/core/actors" class="lang">中文 (简体)</a></li>
        
          
          <li><a href="/es/overviews/core/actors" class="lang">Español</a></li>
        
      </ul>
      
    </div>

    <div class="span10">
      <p><strong>Philipp Haller and Stephen Tu</strong></p>

<p><strong>Traducción e interpretación: Miguel Ángel Pastor Olivar</strong></p>

<h2 id="introduccin">Introducción</h2>

<p>La presente guía describe el API del paquete <code class="highlighter-rouge">scala.actors</code> de Scala 2.8/2.9. El documento se estructura en diferentes grupos lógicos. La jerarquía de “traits” es tenida en cuenta para llevar a cabo la estructuración de las secciones individuales. La atención se centra en el comportamiento exhibido en tiempo de ejecución por varios de los métodos presentes en los traits anteriores, complementando la documentación existente en el Scaladoc API.</p>

<h2 id="traits-de-actores-reactor-replyreactor-y-actor">Traits de actores: Reactor, ReplyReactor, y Actor</h2>

<h3 id="the-reactor-trait">The Reactor trait</h3>

<p><code class="highlighter-rouge">Reactor</code> es el padre de todos los traits relacionados con los actores. Heredando de este trait podremos definir actores con una funcionalidad básica de envío y recepción de mensajes.</p>

<p>El comportamiento de un <code class="highlighter-rouge">Reactor</code> se define mediante la implementación de su método <code class="highlighter-rouge">act</code>. Este método es ejecutado una vez el <code class="highlighter-rouge">Reactor</code> haya sido iniciado mediante la invocación del método <code class="highlighter-rouge">start</code>, retornando el <code class="highlighter-rouge">Reactor</code>. El método <code class="highlighter-rouge">start</code>es <em>idempotente</em>, lo cual significa que la invocación del mismo sobre un actor que ya ha sido iniciado no surte ningún efecto.</p>

<p>El trait <code class="highlighter-rouge">Reactor</code> tiene un parámetro de tipo <code class="highlighter-rouge">Msg</code> el cual determina el tipo de mensajes que un actor es capaz de recibir.</p>

<p>La invocación del método <code class="highlighter-rouge">!</code> de un <code class="highlighter-rouge">Reactor</code> envía un mensaje al receptor. La operación de envío de un mensaje mediante el operador <code class="highlighter-rouge">!</code> es asíncrona por lo que el actor que envía el mensaje no se bloquea esperando a que el mensaje sea recibido sino que su ejecución continua de manera inmediata. Por ejemplo, <code class="highlighter-rouge">a ! msg</code> envia <code class="highlighter-rouge">msg</code> a <code class="highlighter-rouge">a</code>. Todos los actores disponen de un <em>buzón</em> encargado de regular los mensajes entrantes hasta que son procesados.</p>

<p>El trait <code class="highlighter-rouge">Reactor</code> trait también define el método <code class="highlighter-rouge">forward</code>. Este método es heredado de <code class="highlighter-rouge">OutputChannel</code> y tiene el mismo efecto que el método <code class="highlighter-rouge">!</code>. Aquellos traits que hereden de <code class="highlighter-rouge">Reactor</code>, en particular el trait <code class="highlighter-rouge">ReplyActor</code>, sobreescriben este método para habilitar lo que comunmente se conocen como <em>“implicit reply destinations”</em> (ver a continuación)</p>

<p>Un <code class="highlighter-rouge">Reactor</code> recibe mensajes utilizando el método <code class="highlighter-rouge">react</code>. Este método espera un argumento de tipo <code class="highlighter-rouge">PartialFunction[Msg, Unit]</code> el cual define cómo los mensajes de tipo <code class="highlighter-rouge">Msg</code> son tratados una vez llegan al buzón de un actor. En el siguiente ejemplo, el actor espera recibir la cadena “Hello”, para posteriomente imprimir un saludo:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>react {
  case "Hello" =&gt; println("Hi there")
}
</code></pre>
</div>

<p>La invocación del método <code class="highlighter-rouge">react</code> nunca retorna. Por tanto, cualquier código que deba ejecutarse tras la recepción de un mensaje deberá ser incluido dentro de la función parcial pasada al método <code class="highlighter-rouge">react</code>. Por ejemplo, dos mensajes pueden ser recibidos secuencialmente mediante la anidación de dos llamadas a <code class="highlighter-rouge">react</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>react {
  case Get(from) =&gt;
    react {
      case Put(x) =&gt; from ! x
    }
}
</code></pre>
</div>

<p>El trait <code class="highlighter-rouge">Reactor</code> también ofrece una serie de estructuras de control que facilitan la programación utilizando el mecanismo de <code class="highlighter-rouge">react</code>.</p>

<h4 id="terminacin-y-estados-de-ejecucin">Terminación y estados de ejecución</h4>

<p>La ejecución de un <code class="highlighter-rouge">Reactor</code> finaliza cuando el cuerpo del método <code class="highlighter-rouge">act</code> ha sido completado. Un <code class="highlighter-rouge">Reactor</code> también pueden terminarse a si mismo de manera explícita mediante el uso del método <code class="highlighter-rouge">exit</code>. El tipo de retorno de <code class="highlighter-rouge">exit</code> es <code class="highlighter-rouge">Nothing</code>, dado que <code class="highlighter-rouge">exit</code> siempre dispara una excepción. Esta excepción únicamente se utiliza de manera interna y nunca debería ser capturada.</p>

<p>Un <code class="highlighter-rouge">Reactor</code> finalizado pueden ser reiniciado mediante la invocación de su método <code class="highlighter-rouge">restart</code>. La invocación del método anterior sobre un <code class="highlighter-rouge">Reactor</code> que no ha terminado su ejecución lanza una excepción de tipo <code class="highlighter-rouge">IllegalStateException</code>. El reinicio de un actor que ya ha terminado provoca que el método <code class="highlighter-rouge">act</code> se ejecute nuevamente.</p>

<p>El tipo <code class="highlighter-rouge">Reactor</code> define el método <code class="highlighter-rouge">getState</code>, el cual retorna, como un miembro de la enumeración <code class="highlighter-rouge">Actor.State</code>, el estado actual de la ejecución del actor. Un actor que todavía no ha sido iniciado se encuentra en el estado <code class="highlighter-rouge">Actor.State.New</code>. Si el actor se está ejecutando pero no está esperando por ningún mensaje su estado será <code class="highlighter-rouge">Actor.State.Runnable</code>. En caso de que el actor haya sido suspendido mientras espera por un mensaje estará en el estado <code class="highlighter-rouge">Actor.State.Suspended</code>. Por último, un actor ya terminado se encontrará en el estado <code class="highlighter-rouge">Actor.State.Terminated</code>.</p>

<h4 id="manejo-de-excepciones">Manejo de excepciones</h4>

<p>El miembro <code class="highlighter-rouge">exceptionHandler</code> permite llevar a cabo la definición de un manejador de excepciones que estará habilitado durante toda la vida del <code class="highlighter-rouge">Reactor</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def exceptionHandler: PartialFunction[Exception, Unit]
</code></pre>
</div>

<p>Este manejador de excepciones (<code class="highlighter-rouge">exceptionHandler</code>) retorna una función parcial que se utiliza para gestionar excepciones que no hayan sido tratadas de ninguna otra manera. Siempre que una excepción se propague fuera del método <code class="highlighter-rouge">act</code> de un <code class="highlighter-rouge">Reactor</code> el manejador anterior será aplicado a dicha excepción, permitiendo al actor ejecutar código de limpieza antes de que se termine. Nótese que la visibilidad de <code class="highlighter-rouge">exceptionHandler</code> es <code class="highlighter-rouge">protected</code>.</p>

<p>El manejo de excepciones mediante el uso de <code class="highlighter-rouge">exceptionHandler</code> encaja a la perfección con las estructuras de control utilizadas para programas con el método <code class="highlighter-rouge">react</code>. Siempre que una excepción es manejada por la función parcial retornada por <code class="highlighter-rouge">excepctionHandler</code>, la ejecución continua con la “closure” actual:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>loop {
  react {
    case Msg(data) =&gt;
      if (cond) // process data
      else throw new Exception("cannot process data")
  }
}
</code></pre>
</div>

<p>Assumiendo que <code class="highlighter-rouge">Reactor</code> sobreescribe el atributo <code class="highlighter-rouge">exceptionHandler</code>, tras el lanzamiento de una excepción en el cuerpo del método <code class="highlighter-rouge">react</code>, y una vez ésta ha sido gestionada, la ejecución continua con la siguiente iteración del bucle.</p>

<h3 id="the-replyreactor-trait">The ReplyReactor trait</h3>

<p>El trait <code class="highlighter-rouge">ReplyReactor</code> extiende <code class="highlighter-rouge">Reactor[Any]</code> y sobrescribe y/o añade los siguientes métodos:</p>

<ul>
  <li>
    <p>El método <code class="highlighter-rouge">!</code> es sobrescrito para obtener una referencia al actor
actual (el emisor). Junto al mensaje actual, la referencia a dicho
emisor es enviada al buzón del actor receptor. Este último dispone de
acceso al emisor del mensaje mediante el uso del método <code class="highlighter-rouge">sender</code> (véase más abajo).</p>
  </li>
  <li>
    <p>El método <code class="highlighter-rouge">forward</code> es sobrescrito para obtener una referencia al emisor
del mensaje que actualmente está siendo procesado. Junto con el mensaje
actual, esta referencia es enviada como el emisor del mensaje actual.
Como consuencia de este hecho, <code class="highlighter-rouge">forward</code> nos permite reenviar mensajes
en nombre de actores diferentes al actual.</p>
  </li>
  <li>
    <p>El método (añadido) <code class="highlighter-rouge">sender</code> retorna el emisor del mensaje que está siendo
actualmente procesado. Puesto que un mensaje puede haber sido reenviado,
<code class="highlighter-rouge">sender</code> podría retornar un actor diferente al que realmente envió el mensaje.</p>
  </li>
  <li>
    <p>El método (añadido) <code class="highlighter-rouge">reply</code> envía una respuesta al emisor del último mensaje.
<code class="highlighter-rouge">reply</code> también es utilizado para responder a mensajes síncronos o a mensajes
que han sido enviados mediante un “future” (ver más adelante).</p>
  </li>
  <li>
    <p>El método (añadido) <code class="highlighter-rouge">!?</code> ofrece un <em>mecanismo síncrono de envío de mensajes</em>.
La invocación de <code class="highlighter-rouge">!?</code> provoca que el actor emisor del mensaje se bloquee hasta
que se recibe una respuesta, momento en el cual retorna dicha respuesta. Existen
dos variantes sobrecargadas. La versión con dos parámetros recibe un argumento
adicional que representa el tiempo de espera (medido en milisegundos) y su tipo
de retorno es <code class="highlighter-rouge">Option[Any]</code> en lugar de <code class="highlighter-rouge">Any</code>. En caso de que el emisor no
reciba una respuesta en el periodo de espera establecido, el método <code class="highlighter-rouge">!?</code> retornará
<code class="highlighter-rouge">None</code>; en otro caso retornará la respuesta recibida recubierta con <code class="highlighter-rouge">Some</code>.</p>
  </li>
  <li>
    <p>Los métodos (añadidos) <code class="highlighter-rouge">!!</code> son similares al envío síncrono de mensajes en el sentido de
que el receptor puede enviar una respuesta al emisor del mensaje. Sin embargo, en lugar
de bloquear el actor emisor hasta que una respuesta es recibida, retornan una instancia de
<code class="highlighter-rouge">Future</code>. Esta última puede ser utilizada para recuperar la respuesta del receptor una
vez se encuentre disponible; asimismo puede ser utilizada para comprobar si la respuesta
está disponible sin la necesidad de bloquear el emisor. Existen dos versiones sobrecargadas.
La versión que acepta dos parámetros recibe un argumento adicional de tipo
<code class="highlighter-rouge">PartialFunction[Any, A]</code>. Esta función parcial es utilizada para realizar el post-procesado de
la respuesta del receptor. Básicamente, <code class="highlighter-rouge">!!</code> retorna un “future” que aplicará la anterior
función parcial a la repuesta (una vez recibida). El resultado del “future” es el resultado
de este post-procesado.</p>
  </li>
  <li>
    <p>El método (añadido) <code class="highlighter-rouge">reactWithin</code> permite llevar a cabo la recepción de mensajes en un periodo
determinado de tiempo. En comparación con el método <code class="highlighter-rouge">react</code>, recibe un parámetro adicional,
<code class="highlighter-rouge">msec</code>, el cual representa el periodo de tiempo, expresado en milisegundos, hasta que el patrón <code class="highlighter-rouge">TIMEOUT</code>
es satisfecho (<code class="highlighter-rouge">TIMEOUT</code> es un “case object” presente en el paquete <code class="highlighter-rouge">scala.actors</code>). Ejemplo:</p>

    <p>reactWithin(2000) {
    case Answer(text) =&gt; // process text
    case TIMEOUT =&gt; println(“no answer within 2 seconds”)
  }</p>
  </li>
  <li>
    <p>El método <code class="highlighter-rouge">reactWithin</code> también permite realizar accesos no bloqueantes al buzón. Si
especificamos un tiempo de espera de 0 milisegundos, primeramente el buzón será escaneado
en busca de un mensaje que concuerde. En caso de que no exista ningún mensaje concordante
tras el primer escaneo, el patrón <code class="highlighter-rouge">TIMEOUT</code> será satisfecho. Por ejemplo, esto nos permite
recibir determinado tipo de mensajes donde unos tienen una prioridad mayor que otros:</p>

    <p>reactWithin(0) {
    case HighPriorityMsg =&gt; // …
    case TIMEOUT =&gt;
      react {
        case LowPriorityMsg =&gt; // …
      }
  }</p>

    <p>En el ejemplo anterior, el actor procesa en primer lugar los mensajes <code class="highlighter-rouge">HighPriorityMsg</code> aunque
exista un mensaje <code class="highlighter-rouge">LowPriorityMsg</code> más antiguo en el buzón. El actor sólo procesará mensajes
<code class="highlighter-rouge">LowPriorityMsg</code> en primer lugar en aquella situación donde no exista ningún <code class="highlighter-rouge">HighProrityMsg</code>
en el buzón.</p>
  </li>
</ul>

<p>Adicionalmente, el tipo <code class="highlighter-rouge">ReplyActor</code> añade el estado de ejecución <code class="highlighter-rouge">Actor.State.TimedSuspended</code>. Un actor suspendido, esperando la recepción de un mensaje mediante el uso de <code class="highlighter-rouge">reactWithin</code> se encuentra en dicho estado.</p>

<h3 id="el-trait-actor">El trait Actor</h3>

<p>El trait <code class="highlighter-rouge">Actor</code> extiende de <code class="highlighter-rouge">ReplyReactor</code> añadiendo y/o sobrescribiendo los siguientes miembros:</p>

<ul>
  <li>
    <p>El método (añadido) <code class="highlighter-rouge">receive</code> se comporta del mismo modo que <code class="highlighter-rouge">react</code>, con la excepción
de que puede retornar un resultado. Este hecho se ve reflejado en la definición del tipo,
que es polimórfico en el tipo del resultado: <code class="highlighter-rouge">def receive[R](f: PartialFunction[Any, R]): R</code>.
Sin embargo, la utilización de <code class="highlighter-rouge">receive</code> hace que el uso del actor
sea más pesado, puesto que el hilo subyacente es bloqueado mientras
el actor está esperando por la respuesta. El hilo bloqueado no está
disponible para ejecutar otros actores hasta que la invocación del
método <code class="highlighter-rouge">receive</code> haya retornado.</p>
  </li>
  <li>
    <p>El método (añadido) <code class="highlighter-rouge">link</code> permite a un actor enlazarse y desenlazarse de otro
actor respectivamente. El proceso de enlazado puede utilizarse para monitorizar
y responder a la terminación de un actor. En particular, el proceso de enlazado
afecta al comportamiento mostrado en la ejecución del método <code class="highlighter-rouge">exit</code> tal y como
se escribe en el la documentación del API del trait <code class="highlighter-rouge">Actor</code>.</p>
  </li>
  <li>
    <p>El atributo <code class="highlighter-rouge">trapExit</code> permite responder a la terminación de un actor enlazado,
independientemente de los motivos de su terminación (es decir, carece de importancia
si la terminación del actor es normal o no). Si <code class="highlighter-rouge">trapExit</code> toma el valor cierto en
un actor, este nunca terminará por culpa de los actores enlazados. En cambio, siempre
y cuando uno de sus actores enlazados finalice, recibirá un mensaje de tipo <code class="highlighter-rouge">Exit</code>.
<code class="highlighter-rouge">Exit</code> es una “case class” que presenta dos atributos: <code class="highlighter-rouge">from</code> referenciando al actor
que termina y <code class="highlighter-rouge">reason</code> conteniendo los motivos de la terminación.</p>
  </li>
</ul>

<h4 id="terminacin-y-estados-de-ejecucin-1">Terminación y estados de ejecución</h4>

<p>Cuando la ejecución de un actor finaliza, el motivo de dicha terminación puede ser
establecida de manera explícita mediante la invocación de la siguiente variante
del método <code class="highlighter-rouge">exit</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def exit(reason: AnyRef): Nothing
</code></pre>
</div>

<p>Un actor cuyo estado de terminación es diferente del símbolo <code class="highlighter-rouge">'normal</code> propaga
los motivos de su terminación a todos aquellos actores que se encuentren enlazados
a él. Si el motivo de la terminación es una excepción no controlada, el motivo de
finalización será una instancia de la “case class” <code class="highlighter-rouge">UncaughtException</code>.</p>

<p>El trait <code class="highlighter-rouge">Actor</code> incluye dos nuevos estados de ejecución. Un actor que se encuentra
esperando la recepción de un mensaje mediante la utilización del método <code class="highlighter-rouge">receive</code> se
encuentra en el método <code class="highlighter-rouge">Actor.State.Blocked</code>. Un actor esperado la recepción de un
mensaje mediante la utilización del método <code class="highlighter-rouge">receiveWithin</code> se encuentra en el estado
<code class="highlighter-rouge">Actor.State.TimeBlocked</code>.</p>

<h2 id="estructuras-de-control">Estructuras de control</h2>

<p>El trait <code class="highlighter-rouge">Reactor</code> define una serie de estructuras de control que simplifican el mecanismo
de programación con la función sin retorno <code class="highlighter-rouge">react</code>. Normalmente, una invocación al método
<code class="highlighter-rouge">react</code> no retorna nunca. Si el actor necesita ejecutar código a continuación de la invocación
anterior, tendrá que pasar, de manera explícita, dicho código al método <code class="highlighter-rouge">react</code> o utilizar
algunas de las estructuras que encapsulan este comportamiento.</p>

<p>La estructura de control más basica es <code class="highlighter-rouge">andThen</code>. Permite registrar una <code class="highlighter-rouge">closure</code> que será
ejecutada una vez el actor haya terminado la ejecución de todo lo demas.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>actor {
  {
    react {
      case "hello" =&gt; // processing "hello"
    }: Unit
  } andThen {
    println("hi there")
  }
}
</code></pre>
</div>

<p>Por ejemplo, el actor anterior imprime un saludo tras realizar el procesado
del mensaje <code class="highlighter-rouge">hello</code>. Aunque la invocación del método <code class="highlighter-rouge">react</code> no retorna,
podemos utilizar <code class="highlighter-rouge">andThen</code> para registrar el código encargado de imprimir
el saludo a continuación de la ejecución del actor.</p>

<p>Nótese que existe una <em>atribución de tipo</em> a continuación de la invocación
de <code class="highlighter-rouge">react</code> (<code class="highlighter-rouge">:Unit</code>). Básicamente, nos permite tratar el resultado de
<code class="highlighter-rouge">react</code> como si fuese de tipo <code class="highlighter-rouge">Unit</code>, lo cual es legal, puesto que el resultado
de una expresión siempre se puede eliminar. Es necesario llevar a cabo esta operación
dado que <code class="highlighter-rouge">andThen</code> no puede ser un miembro del tipo <code class="highlighter-rouge">Unit</code>, que es el tipo del resultado
retornado por <code class="highlighter-rouge">react</code>. Tratando el tipo de resultado retornado por <code class="highlighter-rouge">react</code> como
<code class="highlighter-rouge">Unit</code> permite llevar a cabo la aplicación de una conversión implícita la cual
hace que el miembro <code class="highlighter-rouge">andThen</code> esté disponible.</p>

<p>El API ofrece unas cuantas estructuras de control adicionales:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">loop { ... }</code>. Itera de manera indefinidia, ejecutando el código entre
las llaves en cada una de las iteraciones. La invocación de <code class="highlighter-rouge">react</code> en el
cuerpo del bucle provoca que el actor se comporte de manera habitual ante
la llegada de un nuevo mensaje. Posteriormente a la recepción del mensaje,
la ejecución continua con la siguiente iteración del bucle actual.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">loopWhile (c) { ... }</code>. Ejecuta el código entre las llaves mientras la
condición <code class="highlighter-rouge">c</code> tome el valor <code class="highlighter-rouge">true</code>. La invocación de <code class="highlighter-rouge">react</code> en el cuerpo
del bucle ocasiona el mismo efecto que en el caso de <code class="highlighter-rouge">loop</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">continue</code>. Continua con la ejecución de la closure actual. La invocación
de <code class="highlighter-rouge">continue</code> en el cuerpo de un <code class="highlighter-rouge">loop</code>o <code class="highlighter-rouge">loopWhile</code> ocasionará que el actor
termine la iteración en curso y continue con la siguiente. Si la iteración en
curso ha sido registrada utilizando <code class="highlighter-rouge">andThen</code>, la ejecución continua con la
segunda “closure” pasada como segundo argumento a <code class="highlighter-rouge">andThen</code>.</p>
  </li>
</ul>

<p>Las estructuras de control pueden ser utilizadas en cualquier parte del cuerpo
del método <code class="highlighter-rouge">act</code> y en los cuerpos de los métodos que, transitivamente, son
llamados por <code class="highlighter-rouge">act</code>. Aquellos actores creados utilizando la sintáxis <code class="highlighter-rouge">actor { ... }</code>
pueden importar las estructuras de control desde el objeto <code class="highlighter-rouge">Actor</code>.</p>

<h4 id="futures">Futures</h4>

<p>Los traits <code class="highlighter-rouge">RepyActor</code> y <code class="highlighter-rouge">Actor</code> soportan operaciones de envío de mensajes
(métodos <code class="highlighter-rouge">!!</code>) que, de manera inmediata, retornan un <em>future</em>. Un <em>future</em>,
es una instancia del trait <code class="highlighter-rouge">Future</code> y actúa como un manejador que puede
ser utilizado para recuperar la respuesta a un mensaje “send-with-future”.</p>

<p>El emisor de un mensaje “send-with-future” puede esperar por la respuesta del
future <em>aplicando</em> dicha future. Por ejemplo, el envío de un mensaje mediante
<code class="highlighter-rouge">val fut = a !! msg</code> permite al emisor esperar por el resultado del future
del siguiente modo: <code class="highlighter-rouge">val res = fut()</code>.</p>

<p>Adicionalmente, utilizando el método <code class="highlighter-rouge">isSet</code>, un <code class="highlighter-rouge">Future</code> puede ser consultado
de manera no bloqueante para comprobar si el resultado está disponible.</p>

<p>Un mensaje “send-with-future” no es el único modo de obtener una referencia a
un future. Estos pueden ser creados utilizando el método <code class="highlighter-rouge">future</code>. En el siguiente
ejemplo, <code class="highlighter-rouge">body</code> se ejecuta de manera concurrente, retornando un future como
resultado.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>val fut = Future { body }
// ...
fut() // wait for future
</code></pre>
</div>

<p>Lo que hace especial a los futures en el contexto de los actores es la posibilidad
de recuperar su resultado utilizando las operaciones estándar de actores de
recepción de mensajes como <code class="highlighter-rouge">receive</code>, etc. Además, es posible utilizar las operaciones
basadas en eventos <code class="highlighter-rouge">react</code>y <code class="highlighter-rouge">reactWithin</code>. Esto permite a un actor esperar por el
resultado de un future sin la necesidad de bloquear el hilo subyacente.</p>

<p>Las operaciones de recepción basadas en actores están disponibles a través del
atributo <code class="highlighter-rouge">inputChannel</code> del future. Dado un future de tipo <code class="highlighter-rouge">Future[T]</code>, el tipo
de <code class="highlighter-rouge">inputChannel</code> es <code class="highlighter-rouge">InputChannel[T]</code>. Por ejemplo:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>val fut = a !! msg
// ...
fut.inputChannel.react {
  case Response =&gt; // ...
}
</code></pre>
</div>

<h2 id="canales">Canales</h2>

<p>Los canales pueden ser utilizados para simplificar el manejo de mensajes
que presentan tipos diferentes pero que son enviados al mismo actor. La
jerarquía de canales se divide en <code class="highlighter-rouge">OutputChannel</code> e <code class="highlighter-rouge">InputChannel</code>.</p>

<p>Los <code class="highlighter-rouge">OutputChannel</code> pueden ser utilizados para enviar mensajes. Un
<code class="highlighter-rouge">OutputChannel</code> <code class="highlighter-rouge">out</code> soporta las siguientes operaciones:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">out ! msg</code>. Envía el mensaje <code class="highlighter-rouge">msg</code> a <code class="highlighter-rouge">out</code> de manera asíncrona. Cuando <code class="highlighter-rouge">msg</code>
es enviado directamente a un actor se incluye un referencia al actor emisor
del mensaje.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">out forward msg</code>. Reenvía el mensaje <code class="highlighter-rouge">msg</code> a <code class="highlighter-rouge">out</code> de manera asíncrona.
El actor emisor se determina en el caso en el que <code class="highlighter-rouge">msg</code> es reenviado a
un actor.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">out.receiver</code>. Retorna el único actor que está recibiendo mensajes que están
siendo enviados al canal <code class="highlighter-rouge">out</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">out.send(msg, from)</code>. Envía el mensaje <code class="highlighter-rouge">msg</code> a <code class="highlighter-rouge">out</code> de manera asíncrona,
proporcionando a <code class="highlighter-rouge">from</code> como el emisor del mensaje.</p>
  </li>
</ul>

<p>Nótese que el trait <code class="highlighter-rouge">OutputChannel</code> tiene un parámetro de tipo que especifica el
tipo de los mensajes que pueden ser enviados al canal (utilizando <code class="highlighter-rouge">!</code>, <code class="highlighter-rouge">forward</code>,
y <code class="highlighter-rouge">send</code>). Este parámetro de tipo es contra-variante:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>trait OutputChannel[-Msg]
</code></pre>
</div>

<p>Los actores pueden recibir mensajes de un <code class="highlighter-rouge">InputChannel</code>. Del mismo modo que
<code class="highlighter-rouge">OutputChannel</code>, el trait <code class="highlighter-rouge">InputChannel</code> presenta un parámetro de tipo que
especifica el tipo de mensajes que pueden ser recibidos por el canal. En este caso,
el parámetro de tipo es covariante:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>trait InputChannel[+Msg]
</code></pre>
</div>

<p>Un <code class="highlighter-rouge">InputChannel[Msg]</code> <code class="highlighter-rouge">in</code>  soportal las siguientes operaciones.</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">in.receive { case Pat1 =&gt; ... ; case Patn =&gt; ... }</code> (y de manera similar,
<code class="highlighter-rouge">in.receiveWithin</code>) recibe un mensaje proveniente de <code class="highlighter-rouge">in</code>. La invocación
del método <code class="highlighter-rouge">receive</code> en un canal de entrada presenta la misma semántica
que la operación estándar de actores <code class="highlighter-rouge">receive</code>. La única diferencia es que
la función parcial pasada como argumento tiene tipo <code class="highlighter-rouge">PartialFunction[Msg, R]</code>
donde <code class="highlighter-rouge">R</code> es el tipo de retorno de <code class="highlighter-rouge">receive</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">in.react { case Pat1 =&gt; ... ; case Patn =&gt; ... }</code> (y de manera similar,
<code class="highlighter-rouge">in.reactWithin</code>). Recibe un mensaje de <code class="highlighter-rouge">in</code> utilizando la operación basada en
eventos <code class="highlighter-rouge">react</code>. Del mismo modo que la operación <code class="highlighter-rouge">react</code> en actores, el tipo
de retorno es <code class="highlighter-rouge">Nothing</code>, indicando que las invocaciones de este método nunca
retornan. Al igual que la operación <code class="highlighter-rouge">receive</code> anterior, la función parcial
que se pasa como argumento presenta un tipo más específico:</p>

    <p>PartialFunction[Msg, Unit]</p>
  </li>
</ul>

<h3 id="creando-y-compartiendo-canales">Creando y compartiendo canales</h3>

<p>Los canales son creados utilizando la clase concreta <code class="highlighter-rouge">Channel</code>. Esta clase extiende
de <code class="highlighter-rouge">InputChannel</code> y <code class="highlighter-rouge">OutputChannel</code>. Un canal pueden ser compartido haciendo dicho
canal visible en el ámbito de múltiples actores o enviándolo como mensaje.</p>

<p>El siguiente ejemplo muestra la compartición mediante publicación en ámbitos:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>actor {
  var out: OutputChannel[String] = null
  val child = actor {
    react {
      case "go" =&gt; out ! "hello"
    }
  }
  val channel = new Channel[String]
  out = channel
  child ! "go"
  channel.receive {
    case msg =&gt; println(msg.length)
  }
}
</code></pre>
</div>

<p>La ejecución de este ejemplo imprime la cadena “5” en la consola. Nótese que el
actor <code class="highlighter-rouge">child</code> únicamente tiene acceso a <code class="highlighter-rouge">out</code>, que es un <code class="highlighter-rouge">OutputChannel[String]</code>.
La referencia al canal, la cual puede ser utilizada para llevar a cabo la recepción
de mensajes, se encuentra oculta. Sin embargo, se deben tomar precauciones y
asegurarse que el canal de salida es inicializado con un canal concreto antes de que
<code class="highlighter-rouge">child</code> le envíe ningún mensaje. En el ejemplo que nos ocupa, esto es llevado a cabo
mediante el mensaje “go”. Cuando se está recibiendo de <code class="highlighter-rouge">channel</code> utilizando el método
<code class="highlighter-rouge">channel.receive</code> podemos hacer uso del hecho que <code class="highlighter-rouge">msg</code> es de tipo <code class="highlighter-rouge">String</code>, y por
lo tanto tiene un miembro <code class="highlighter-rouge">length</code>.</p>

<p>Una alternativa a la compartición de canales es enviarlos a través de mensajes.
El siguiente fragmento de código muestra un sencillo ejemplo de aplicación:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>case class ReplyTo(out: OutputChannel[String])

val child = actor {
  react {
    case ReplyTo(out) =&gt; out ! "hello"
  }
}

actor {
  val channel = new Channel[String]
  child ! ReplyTo(channel)
  channel.receive {
    case msg =&gt; println(msg.length)
  }
}
</code></pre>
</div>

<p>La “case class” <code class="highlighter-rouge">ReplyTo</code> es un tipo de mensajes que utilizamos para distribuir
una referencia a un <code class="highlighter-rouge">OutputChannel[String]</code>. Cuando el actor <code class="highlighter-rouge">child</code> recibe un
mensaje de tipo <code class="highlighter-rouge">ReplyTo</code> éste envía una cadena a su canal de salida. El segundo
actor recibe en el canal del mismo modo que anteriormente.</p>

<h2 id="planificadores">Planificadores</h2>

<p>Un <code class="highlighter-rouge">Reactor</code>(o una instancia de uno de sus subtipos) es ejecutado utilizando un
<em>planificador</em>. El trait <code class="highlighter-rouge">Reactor</code> incluye el miembro <code class="highlighter-rouge">scheduler</code> el cual retorna el
planificador utilizado para ejecutar sus instancias:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def scheduler: IScheduler
</code></pre>
</div>

<p>La plataforma de ejecución ejecuta los actores enviando tareas al planificador mediante
el uso de los métodos <code class="highlighter-rouge">execute</code> definidos en el trait <code class="highlighter-rouge">IScheduler</code>. La mayor parte
del resto de métodos definidos en este trait únicamente adquieren cierto protagonismo
cuando se necesita implementar un nuevo planificador desde cero; algo que no es necesario
en muchas ocasiones.</p>

<p>Los planificadores por defecto utilizados para ejecutar instancias de <code class="highlighter-rouge">Reactor</code> y
<code class="highlighter-rouge">Actor</code> detectan cuando los actores han finalizado su ejecución. En el momento que esto
ocurre, el planificador se termina a si mismo (terminando con cualquier hilo que estuviera
en uso por parte del planificador). Sin embargo, algunos planificadores como el
<code class="highlighter-rouge">SingleThreadedScheduler</code> (definido en el paquete <code class="highlighter-rouge">scheduler</code>) necesita ser terminado de
manera explícita mediante la invocación de su método <code class="highlighter-rouge">shutdown</code>).</p>

<p>La manera más sencilla de crear un planificador personalizado consisten en extender la clase
<code class="highlighter-rouge">SchedulerAdapter</code>, implementando el siguiente método abstracto:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def execute(fun: =&gt; Unit): Unit
</code></pre>
</div>

<p>Por norma general, una implementación concreata utilizaría un pool de hilos para llevar a cabo
la ejecución del argumento por nombre <code class="highlighter-rouge">fun</code>.</p>

<h2 id="actores-remotos">Actores remotos</h2>

<p>Esta sección describe el API de los actores remotos. Su principal interfaz es el objecto
<a href="http://www.scala-lang.org/api/2.9.1/scala/actors/remote/RemoteActor$.html"><code class="highlighter-rouge">RemoteActor</code></a> definido
en el paquete <code class="highlighter-rouge">scala.actors.remote</code>. Este objeto facilita el conjunto de métodos necesarios para crear
y establecer conexiones a instancias de actores remotos. En los fragmentos de código que se muestran a
continuación se asume que todos los miembros de <code class="highlighter-rouge">RemoteActor</code> han sido importados; la lista completa
de importaciones utilizadas es la siguiente:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import scala.actors._
import scala.actors.Actor._
import scala.actors.remote._
import scala.actors.remote.RemoteActor._
</code></pre>
</div>

<h3 id="iniciando-actores-remotos">Iniciando actores remotos</h3>

<p>Un actore remot es identificado de manera unívoca por un
<a href="http://www.scala-lang.org/api/2.9.1/scala/Symbol.html"><code class="highlighter-rouge">Symbol</code></a>. Este símbolo es único para la instancia
de la máquina virual en la que se está ejecutando un actor. Un actor remoto identificado con el nombre
<code class="highlighter-rouge">myActor</code> puede ser creado del siguiente modo.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class MyActor extends Actor {
  def act() {
    alive(9000)
    register('myActor, self)
    // ...
  }
}
</code></pre>
</div>

<p>Nótese que el nombre únicamente puede ser registrado con un único actor al mismo tiempo.
Por ejemplo, para registrar el actor <em>A</em> como <code class="highlighter-rouge">'myActor</code> y posteriormente registrar otro
actor <em>B</em> como <code class="highlighter-rouge">'myActor</code>, debería esperar hasta que <em>A</em> haya finalizado. Este requisito
aplica a lo largo de todos los puertos, por lo que registrando a <em>B</em> en un puerto diferente
no sería suficiente.</p>

<h3 id="connecting-to-remote-actors">Connecting to remote actors</h3>

<p>Establecer la conexión con un actor remoto es un proceso simple. Para obtener una referencia remota
a un actor remoto que está ejecutándose en la máquina <code class="highlighter-rouge">myMachine</code> en el puerto 8000 con el nombre
<code class="highlighter-rouge">'anActor</code>, tendremos que utilizar <code class="highlighter-rouge">select</code>del siguiente modo:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>val myRemoteActor = select(Node("myMachine", 8000), 'anActor)
</code></pre>
</div>

<p>El actor retornado por <code class="highlighter-rouge">select</code> es de tipo <code class="highlighter-rouge">AbstractActor</code>, que proporciona esencialmente el mismo
interfaz que un actor normal, y por lo tanto es compatible con las habituales operaciones de envío
de mensajes:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>myRemoteActor ! "Hello!"
receive {
  case response =&gt; println("Response: " + response)
}
myRemoteActor !? "What is the meaning of life?" match {
  case 42   =&gt; println("Success")
  case oops =&gt; println("Failed: " + oops)
}
val future = myRemoteActor !! "What is the last digit of PI?"
</code></pre>
</div>

<p>Nótese que la operación <code class="highlighter-rouge">select</code> es perezosa; no inicializa ninguna conexión de red. Simplemente crea
una nueva instancia de <code class="highlighter-rouge">AbstractActor</code> que está preparada para iniciar una nueva conexión de red en el
momento en que sea necesario (por ejemplo cuando el método ‘!’ es invocado).</p>

      
    </div>
    
    <div class="span6">
      <div id="scroller-anchor">
  <div id="scroller">
              
    <p class="contents">Contents</p>
    <div id="toc"></div>    
  </div>
</div>

    </div>
    
	
  </div>
</div>

<div class="footer">
	<div class="container">
		<ul>
			<li><h5>API</h5></li>
			<li><a href="http://www.scala-lang.org/api/current/">Current</a></li>
			<li><a href="http://www.scala-lang.org/files/archive/nightly/2.11.x/api/2.11.x/">Nightly</a></li>
		</ul>
		<ul>
			<li><h5>Learn</h5></li>
			<li><a href="/overviews">Guides & Overviews</a></li>
			<li><a href="/tutorials">Tutorials</a></li>
			<li><a href="/style">Scala Style Guide</a></li>
		</ul>
		<ul>
			<li><h5>Quickref</h5></li>
			<li><a href="/glossary">Glossary</a></li>
			<li><a href="/cheatsheets">Cheatsheets</a></li>
		</ul>
		<ul>
			<li><h5>Contribute</h5></li>
			<li><a href="http://github.com/scala/scala.github.com">Source Code</a></li>
			<li><a href="/contribute.html">Contributors Guide</a></li>
			<li><a href="http://getsatisfaction.com/scaladocs">Suggestions</a></li>
		</ul>
		<ul>
			<li><h5>Other Resources</h5></li>
			<li><a href="/sips">Scala Improvement Process</a></li>
		</ul>
	</div>
	<div class="container copyright">
 		<p>
			Copyright &copy; 2011-2015 EPFL. All rights reserved.
			<a href="https://github.com/scala/scala.github.com/commits/gh-pages.atom"><img align="right" height="20px" width="20px" src="/resources/images/rss.png" alt="RSS feed of updates to the github repo hosting this site"></a>
		</p>
	</div>
</div>

<!-- search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
<script type="text/javascript"> docsearch({
  apiKey: 'b66eaeec6bd214ea6c0fcd2d7b7fdfe8',
  indexName: 'scala-docs',
  inputSelector: '#q',
	autocompleteOptions: {
    debug: true
  },
  algoliaOptions: {
		"hitsPerPage": 5,
		"facetFilters": "(tags:en)"
	}
});
</script>



<script type="text/javascript">
  $('#toc').toc({exclude: 'h1, h5, h6', context: '', autoId: true, numerate: false});
</script>

<script type="text/javascript">
  $(function() {
    moveScroller();
  });
</script>

  </body>
</html>

    
